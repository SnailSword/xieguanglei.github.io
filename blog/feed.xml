<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[一叶斋]]></title>
        <description><![CDATA[一叶障目 一叶知秋]]></description>
        <link>http://xieguanglei.github.io/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Thu, 05 Jan 2017 11:49:45 GMT</lastBuildDate>
        <atom:link href="http://xieguanglei.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[编写「可读」代码的实践]]></title>
            <description><![CDATA[<h1 id="-">编写「可读」代码的实践</h1>
<p>编写<strong>可读</strong>的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是<strong>能够被阅读</strong>，其次才是<strong>能够被正确执行</strong>。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p>
<p>在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。</p>
<blockquote>
<p>JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p>
<p>这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。</p>
</blockquote>
<h2 id="-">变量命名</h2>
<p>变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p>
<p>命名必须传递足够的信息，形如 <code>getData</code> 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 <code>fetchUserInfoAsync</code> 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 <code>Async</code> 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p>
<h3 id="-">命名的基础</h3>
<p>通常，我们使用名词来命名对象，使用动词来命名函数。比如：</p>
<pre><code>monkey.eat(banana)  // the money eats a banana
const apple = pick(tree)  // pick an apple from the tree
</code></pre><p>这两句代码与自然语言（右侧的注释）很接近，即使完全不了解编程的人也能看懂大概。</p>
<p>有时候，我们需要表示某种集合概念，比如数组或哈希对象。这时可以通过名词的复数形式来表示，比如用 <code>bananas</code> 表示一个数组，这个数组的每一项都是一个 <code>banana</code>。如果需要特别强调这种集合的形式，也可以加上 <code>List</code> 或 <code>Map</code> 后缀来显式表示出来，比如用 <code>bananaList</code> 表示数组。</p>
<blockquote>
<p>有些单词的复数形式和单数形式相同，有些不可数的单词没有复数形式（比如 data，information），这时我也会使用 <code>List</code> 等后缀来表示集合概念。</p>
</blockquote>
<h3 id="-">命名的上下文</h3>
<p>变量都是处在<strong>上下文</strong>（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。举个例子，假设我们的程序需要管理一个动物园，程序的代码里有一个名为 <code>feedAnimals</code> 的函数来喂食动物园中的所有动物：</p>
<pre><code>function feedAnimals(food, animals){
  // ...
  // 上下文中有 bananas, peaches, monkey 变量
  const banana = bananas.pop();
  if(banana){
    monkey.eat(banana);
  } else {
    const peach = peaches.pop();
    monkey.eat(peach);
  }
  // ...
}
</code></pre><p>负责喂食动物的函数 <code>feedAnimals</code> 函数的主要逻辑就是：用各种食物把动物园里的各种动物喂饱。也许，每种动物能接受的食物种类不同，也许，我们需要根据各种食物的库存来决定每种动物最终分到的食物，总之在这个上下文中，我们需要关心食物的种类，所以传给 <code>money.eat</code> 方法的实参对象命名为 <code>banana</code> 或者 <code>peach</code>，代码很清楚地表达出了它的关键逻辑：「猴子要么吃香蕉，要么吃桃子（如果没有香蕉了）」。我们肯定不会这样写：</p>
<pre><code>// 我们不会这样写
const food = bananas.pop();
if(food){
  monkey.eat(food);
} else {
  const food = peaches.pop();
  monkey.eat(food);
}
</code></pre><p><code>Monkey#eat</code> 方法内部就不一样了，这个方法很可能是下面这样的（假设 <code>eat</code> 是 <code>Monkey</code> 的基类 <code>Animal</code> 的方法）：</p>
<pre><code>class Animal{
  // ...
  eat(food){
    this.hunger -= food.energy;
  }
  // ...
}

class Monkey extends Animal{ 
  // ... 
}
</code></pre><p>如代码所示，「吃」这个方法的核心逻辑就是根据食物的能量来减少动物（猴子）自身的饥饿度，至于究竟是吃了桃子还是香蕉，我们不关心，所以在这个方法的上下文中，我们直接将表示食物的函数形参命名为 <code>food</code>。</p>
<p>想象一下，假设我们正在编写某个函数，即将写一段公用逻辑，我们会选择去写一个新的功能函数来执行这段公用逻辑。在编写这个新的功能函数过程中，往往会受到之前那个函数的影响，变量的命名也是按照其在之前那个函数中的意义来的。虽然写的时候不感觉有什么阻碍，但是读者阅读的单元是函数（他并不了解之前哪个函数），会被深深地困扰。</p>
<h3 id="-">严格遵循一种命名规范的收益</h3>
<p>如果你能够时刻按照某种严格的规则来命名变量和函数，还能带来一个潜在的好处，那就是你再也不用<strong>记住</strong>哪些之前命名过（甚至其他人命名过）的变量或函数了。特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。比如，「获取用户信息」这个概念，就叫作 <code>fetchUserInfomation</code>，不管是在早晨还是傍晚，不管你是在公司还是家中，你都会将它命名为 <code>fetchUserInfomation</code> 而不是 <code>getUserData</code>。那么当你再次需要使用这个变量时，你根本不用翻阅之前的代码或依赖 IDE 的代码提示功能，你只需要再<strong>命名</strong>一下「获取用户信息」这个概念，就可以得到 <code>fetchUserInfomation</code> 了，是不是很酷？</p>
<h2 id="-">分支结构</h2>
<p>分支是代码里最常见的结构，一段结构清晰的代码单元应当是像二叉树一样，呈现下面的结构。</p>
<pre><code>if (condition1) {
  if (condition2) {
    ...
  } else {
    ...
  }
} else {
  if (condition3) {
    ...
  } else {
    ...
  }
}
</code></pre><p>这种优美的结构能够帮助我们在大脑中迅速绘制一张图，便于我们在脑海中模拟代码的执行。但是，我们大多数人都不会遵循上面这样的结构来写分支代码。以下是一些常见的，在我看来可读性比较差的分支语句的写法：</p>
<h3 id="-return">不好的做法：在分支中 return</h3>
<pre><code>function foo(){
  if(condition){
    // 分支1的逻辑
    return;
  }
  // 分支2的逻辑
}
</code></pre><p>这种分支代码很常见，而且往往分支2的逻辑是先写的，也是函数的主要逻辑，分支1是后来对函数进行修补的过程中产生的。这种分支代码有一个很致命的问题，那就是，如果读者没有注意到分支1中的 <code>return</code>（我敢保证，在使用 IDE 把代码折叠起来后，没人能第一时间注意到这个 <code>return</code>），就不会意识到后面一段代码（分支 2）是有可能不会执行的。我的建议是，把分支2放到一个 <code>else</code> 语句块中，代码就会清晰可读很多：</p>
<pre><code>function foo(){
  if(condition){
    // 分支 1 的逻辑
  } else {
    // 分支 2 的逻辑
  }
}
</code></pre><blockquote>
<p>如果某个分支是空的，我也倾向于留下一个空行，这个空行明确地告诉代码的读者，如果走到这个 <code>else</code>，我什么都不会做。如果你不告诉读者，读者就会产生怀疑，并尝试自己去弄明白。</p>
</blockquote>
<h3 id="-">不好的做法：多个条件复合</h3>
<pre><code>if (condition1 &amp;&amp; condition2 &amp;&amp; condition3) {
  // 分支1：做一些事情
} else {
  // 分支2：其他的事情
}
</code></pre><p>这种代码也很常见：在若干条件同时满足（或有任一满足）的时候做一些主要的事情（分支1，也就是函数的主逻辑），否则就做一些次要的事情（分支2，比如抛异常，输出日志等）。虽然写代码的人知道什么是主要的事情，什么是次要的事情，但是代码的读者并不知道。读者遇到这种代码，就会产生困惑：分支2到底对应了什么条件？</p>
<p>在上面这段代码中，三种条件只要任意一个不成立就会执行到分支2，但这其实<strong>本质</strong>上是多个分支：1)条件1不满足，2)条件1满足而条件2不满足，3)条件1和2都满足而条件3不满足。如果我们笼统地使用同一段代码来处理多个分支，那么就会增加阅读者阅读分支2时的负担（需要考虑多个情况）。更可怕的是，如果后面需要增加一些额外的逻辑（比如，在条件1成立且条件2不成立的时候多输出一条日志），整个 <code>if-else</code> 都可能需要重构。</p>
<p>对这种场景，我通常这样写：</p>
<pre><code>if(condition1){
  if(condition2){
    // 分支1：做一些事情
  }else{
    // 分支2：其他的事情
  }
}else{
  // 分支3：其他的事情
}
</code></pre><p>即使分支2和分支3是完全一样的，我也认为有必要将其分开。虽然多了几行代码，收益却是很客观的。</p>
<blockquote>
<p>万事非绝对。对于一种情况，我不反对将多个条件复合起来，那就是当被复合的多个条件联系十分紧密的时候，比如 <code>if(foo &amp;&amp; foo.bar)</code>。</p>
</blockquote>
<h3 id="-">不好的做法：使用分支改变环境</h3>
<pre><code>let foo = someValue;
if(condition){
  foo = doSomethingTofoo(foo);
}
// 继续使用 foo 做一些事情
</code></pre><p>这种风格的代码很容易出现在那些屡经修补的代码文件中，很可能一开始是没有这个 <code>if</code> 代码块的，后来发现了一个 bug，于是加上了这个 <code>if</code> 代码块，在某些条件下对 <code>foo</code> 做一些特殊的处理。如果你希望项目在迭代过程中，风险越积越高，那么这个习惯绝对算得上「最佳实践」了。</p>
<p>事实上，这样的「补丁」积累起来，很快就会摧毁代码的可读性和可维护性。怎么说呢？当我们在写下上面这段代码中的 <code>if</code> 分支以试图修复 bug 的时候，我们内心存在这样一个假设：我们是<strong>知道</strong>程序在执行到这一行时，<code>foo</code> 什么样子的；但事实是，我们根本<strong>不知道</strong>，因为在这一行之前，<code>foo</code> 很可能已经被另一个人所写的尝试修复另一个 bug 的另一个 if 分支所篡改了。所以，当代码出现问题的时候，我们应当完整地审视一段独立的功能代码（通常是一个函数），并且多花一点时间来修复他，比如：</p>
<pre><code>const foo = condition ? doSomethingToFoo(someValue) : someValue;
</code></pre><p>我们看到，很多风险都是在项目快速迭代的过程中积累下来的。为了「快速」迭代，在添加功能代码的时候，我们有时候连函数这个最小单元的都不去了解，仅仅着眼于自己插入的那几行，希望在那几行中解决/hack掉所有问题，这是十分不可取的。</p>
<p>我认为，项目的迭代再快，其代码质量和可读性都应当有一个底线。这个底线是，当我们在修改代码的时候，应当<strong>完整了解当前修改的这个函数的逻辑</strong>，然后<strong>修改这个函数</strong>，以达到添加功能的目的。注意，这里的「修改一个函数」和「在函数某个位置添加几行代码」是不同的，在「修改一个函数」的时候，为了保证函数功能独立，逻辑清晰，不应该畏惧在这个函数的任意位置增删代码。</p>
<h2 id="-">函数</h2>
<h3 id="-">函数只做一件事情</h3>
<p>有时，我们会自作聪明地写出一些很「通用」的函数。比如，我们有可能写出下面这样一个获取用户信息的函数 <code>fetchUserInfo</code>：其逻辑是：</p>
<p>1) 当传入的参数是用户ID（字符串）时，返回单个用户数据；
2) 而传入的参数是用户ID的列表（数组）时，返回一个数组，其中的每一项是一个用户的数据。</p>
<pre><code>async function fetchUserInfo(id){
  const isSingle = typeof idList === &#39;string&#39;;
  const idList = isSingle ? [id] : id;
  const result = await request.post(&#39;/api/userInfo&#39;, {idList});
  return isSingle ? result[0] : result;
}

// 可以这样调用
const userList = await fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;]);
// 也可以这样调用
const user = await fetchUserInfo(&#39;1017&#39;);
</code></pre><p>这个函数能够做两件事：1)获取多个用户的数据列表；2)获取单个用户的数据。在项目的其他地方调用 <code>fetchUserInfo</code> 函数时，也许我们确实能感到「方便」了一些。但是，代码的读者一定不会有相同的体会，当读者在某处读到 <code>fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;])</code> 这句调用的代码时，他就会立刻对 <code>fetchUserInfo</code> 产生「第一印象」：这个函数需要传入用户ID数组；当他读到另外一种调用形式时，他一定会怀疑自己之前是不是眼睛花了。读者并不了解背后的「潜规则」，除非规则是预先设计好并且及时地更新到文档中。总之，我们绝不该一时兴起就写出上面这种函数。</p>
<p>遵循<strong>一个函数只做一件事</strong>的原则，我们可以将上述功能拆成两个函数<code>fetchMultipleUser</code> 和 <code>fetchSingleUser</code> 来实现。在需要获取用户数据时，只需要选择调用其中的一个函数。</p>
<pre><code>async function fetchMultipleUser(idList){
  return await request.post(&#39;/api/users/&#39;, {idList});
}

async function fetchSingleUser(id){
  return await fetchMultipleUser([id])[0];
}
</code></pre><p>上述改良不仅改善了代码的可读性，也改善了可维护性。举个例子，假设随着项目的迭代，获取单一用户信息的需求不再存在了。</p>
<ul>
<li>如果是改良前，我们会删掉那些「传入单个用户ID来调用 <code>fetchUserInfo</code>」的代码，同时保留剩下的那些「传入多个用户ID调用 <code>fetchUserInfo</code>」的代码， 但是 <code>fetchUserInfo</code> 函数几乎一定不会被更改。这样，函数内部 <code>isSingle</code> 为 <code>true</code> 的分支，就留在了代码中，成了永远都不会执行的「脏代码」，谁愿意看到自己的项目中充斥着永远不会执行的代码呢？</li>
<li>对于改良后的代码，我们（也许借助IDE）能够轻松检测到 <code>fetchSingleUser</code> 已经不会被调用了，然后放心大胆地直接删掉这个函数。</li>
</ul>
<p>那么，如何界定某个函数做的是不是<strong>一件事情</strong>？我的经验是这样：如果一个函数的参数仅仅包含<strong>输入数据（交给函数处理的数据）</strong>，而没有混杂或暗含有<strong>指令</strong>（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是<strong>一件事情</strong>。比如说，改良前的 <code>fetchUserInfo</code> 函数的参数是「多个用户的ID数组<strong>或</strong>单个用户的ID」，这个「或」字其实就暗含了某种指令。</p>
<h3 id="-">函数应适当地处理异常</h3>
<p>有时候，我们会陷入一种很不好的习惯中，那就是，总是去尝试写出永远不会报错的函数。我们会给参数配上默认值，在很多地方使用 <code>||</code> 或者 <code>&amp;&amp;</code> 来避免代码运行出错，仿佛如果你的函数报错会成为某种耻辱似的。而且，当我们尝试去修复一个运行时报错的函数时，我们往往倾向于在报错的那一行添加一些兼容逻辑来避免报错。</p>
<p>举个例子，假设我们需要编写一个获取用户详情的函数，它要返回一个完整的用户信息对象：不仅包含ID，名字等基本信息，也包含诸如「收藏的书籍」等通过额外接口返回的信息。这些额外的接口也许不太稳定：</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUser(id);
  user.favoriteBooks = (await fetchUserFavorits(id)).books;
  // 上面这一行报错了：Can not read property &#39;books&#39; of undefined.
  // ...
}
</code></pre><p>假设 <code>fetchUserFavorites</code> 会时不时地返回 <code>undefined</code>，那么读取其 <code>books</code> 属性自然就会报错。为了修复该问题，我们很可能会这样做：</p>
<pre><code>const favorites = await fetchUserFavorits(id);
user.favoriteBooks = favorites &amp;&amp; favorites.books;
// 这下不会报错了
</code></pre><p>这样做看似解决了问题：的确，<code>getUserDetail</code> 不会再报错了，但同时埋下了更深的隐患。</p>
<p>当 <code>fetchUserFavorites</code> 返回 <code>undefined</code> 时，程序已经处于一种异常状态了，我们没有任何理由放任程序继续运行下去。试想，如果后面的某个时刻（比如用户点击「我收藏的书」选项卡），程序试图遍历 <code>user.favoriteBooks</code> 属性（它被赋值成了<code>undefined</code>），那时也会报错，而且那时排查起来会更加困难。</p>
<p>如何处理上述的情况呢？我认为，如果被我们依赖的 <code>fetchUserFavorits</code> 属于当前的项目，那么 <code>getUserDetail</code> 对此报错真的没什么责任，因为 <code>fetchUserFavorits</code> 就不应该返回 <code>undefined</code>，我们应该去修复 <code>fetchUserFavorits</code>，任务失败时显式地告知出来，或者直接抛出异常。同时，<code>getUserDetail</code> 稍作修改：</p>
<pre><code>// 情况1：显式告知，此时应认为获取不到收藏数据不算致命的错误
const result = await fetchUserFavorits(id);
if(result.success){
  user.favoriteBooks = result.data.books;
} else {
  user.favoriteBooks = []
}

// 情况2：直接抛出异常
user.favoriteBooks = (await fetchUserFavorits(id)).books;
// 这时 `getUserDetail` 不需要改动，任由异常沿着调用栈向上冒泡
</code></pre><p>那么如果 <code>fetchUserFavorits</code> 不在当前项目中，而是依赖的外部模块呢？我认为，这时你就该为选择了这样一个不可靠的模块负责，在 <code>getUserDetail</code> 中增加一些「擦屁股」代码，来避免你的项目的<strong>其他部分</strong>受到侵害。</p>
<pre><code>const favorites = await fetchUserFavorits(id);
if(favorites){
  user.favoriteBooks = favorites.books;
} else {
  throw new Error(&#39;获取用户收藏失败&#39;);
}
</code></pre><h3 id="-">控制函数的副作用</h3>
<p>无副作用的函数，是<strong>不依赖上下文</strong>，也<strong>不改变上下文</strong>的函数。长久依赖，我们已经习惯了去写「有副作用的函数」，毕竟 JavaScript 需要通过副作用去操作环境的 API 完成任务。这就导致了，很多原本可以用纯粹的、无副作用的函数完成任务的场合，我们也会不自觉地采取有副作用的方式。</p>
<p>虽然看上去有点可笑，但我们有时候就是会写出下面这样的代码！</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUserInfo(id);
  await addFavoritesToUser(user);
  ...
}
async function addFavoritesToUser(user){
  const result = await fetchUserFavorits(user.id);
  user.favoriteBooks = result.books;
  user.favoriteSongs = result.songs;
  user.isMusicFan = result.songs.length &gt; 100;
}
</code></pre><p>上面，<code>addFavoritesToUser</code> 函数就是一个「有副作用」的函数，它改变了 <code>users</code>，给它新增了几个个字段。问题在于，仅仅阅读 <code>getUserData</code> 函数的代码完全无法知道，user 会发生怎样的改变。</p>
<p>一个无副作用的函数应该是这样的：</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUserInfo(id);
  const {books, songs, isMusicFan} = await getUserFavorites(id);
  return Object.assign(user, {books, songs, isMusicFan})
}
async function getUserFavorites(id){
  const {books, songs} = await fetchUserFavorits(user.id);
  return {
    books, songs, isMusicFan: result.songs.length &gt; 100
  }
}
</code></pre><p>难道这不是理所当然的形式吗？</p>
<h3 id="-">非侵入性地改造函数</h3>
<p>函数是一段独立和内聚的逻辑。在产品迭代的过程中，我们有时候不得不去修改函数的逻辑，为其添加一些新特性。之前我们也说过，一个函数只应做一件事，如果我们需要添加的新特性，与原先函数中的逻辑没有什么联系，那么决定是否通过<strong>改造这个函数</strong>来添加新功能，应当格外谨慎。</p>
<p>仍然用「向服务器查询用户数据」为例，假设我们有如下这样一个函数（为了让它看上去复杂一些，假设我们使用了一个更基本的 <code>request</code> 库）：</p>
<pre><code>const fetchUserInfo = (userId, callback) =&gt; {
  const param = {
    url: &#39;/api/user&#39;,
    method: &#39;post&#39;,
    payload: {id: userId}
  };
  request(param, callback);
}
</code></pre><p>现在有了一个新需求：为 <code>fetchUserInfo</code> 函数增加一道本地缓存，如果第二次请求同一个 userId 的用户信息，就不再重新向服务器发起请求，而直接以第一次请求得到的数据返回。</p>
<p>按照如下快捷简单的解决方案，改造这个函数只需要五分钟时间：</p>
<pre><code>const userInfoMap = {};
const fetchUserInfo = (userId, callback) =&gt; {
  if(userInfoMap[userId]){            // 新增代码
    callback(userInfoMap[userId]);    // 新增代码
  }else{                              // 新增代码
    const param = {
      // ... 参数
    };
    request(param, (result)=&gt;{
      userInfoMap[userId] = result;   // 新增代码
      callback(result);
    });
  }
}
</code></pre><p>不知你有没有发现，经此改造，这个函数的可读性已经明显降低了。没有缓存机制前，函数很清晰，一眼就能明白，加上新增的几行代码，已经不能一眼就看明白了。</p>
<p>实际上，「缓存」和「获取用户数据」完全是独立的两件事。我提出的方案是，编写一个通用的缓存包装函数（类似装饰器）<code>memorizeThunk</code>，对 <code>fetchUserInfo</code> 进行包装，产出一个新的具有缓存功能的 <code>fetchUserInfoCache</code>，在不破坏原有函数可读性的基础上，提供缓存功能。</p>
<pre><code>const memorizeThunk = (func, reducer) =&gt; {
  const cache = {};
  return (...args, callback) =&gt; {
    const key = reducer(...args);
    if(cache[key]){
      callback(...cache[key]);
    }else{
      func(...args, (...result)=&gt;{
        cache[key] = result;
        callback(...result);
      })
    }
  }
}
const fetchUserInfo = (userInfo, callback) =&gt; {
  // 原来的逻辑
}
const fetchUserInfoCache = memorize(fetchUserInfo, (userId)=&gt;userId);
</code></pre><p>也许实现这个方案需要十五分钟，但是试想一下，如果将来的某个时候，我们又不需要缓存功能了（或者需要提供一个开关来打开/关闭缓存功能），修改代码的负担是怎样的？第一种简单方案，我们需要精准（提心吊胆地）地删掉新增的若干行代码，而我提出的这种方案，是以函数为单位增删的，负担要轻很多，不是吗？</p>
<h2 id="-">类的结构</h2>
<h3 id="-">避免滥用成员函数</h3>
<p>JavaScript 中的类，是 ES6 才有的概念，此前是通过函数和原型链来模拟的。在编写类的时候，我们常常忍不住地写很多没必要的成员函数：当类的某个成员函数的内部逻辑有点复杂了，行数有点多了之后，我们往往会将其中一部分「独立」逻辑拆分出来，实现为类的另一个成员函数。比如，假设我们编写某个 React 组件来显示用户列表，用户列表的形式是<strong>每两个用户为一行</strong>。</p>
<pre><code>class UserList extends React.Component{
  // ...
  chunk = (users) =&gt; {
    // 将 [&#39;张三&#39;, &#39;李四&#39;, &#39;王二&#39;, &#39;麻子&#39;] 转化为 [[&#39;张三&#39;, &#39;李四&#39;], [&#39;王二&#39;, &#39;麻子&#39;]]
  }
  render(){
    const chunks = this.chunk(this.props.users);
    // 每两个用户为一行
    return (
      &lt;div&gt;
        {chunks.map(users=&gt;
          &lt;row&gt;
            {users.map(user =&gt; 
              &lt;col&gt;&lt;UserItem user={user}&gt;&lt;/col&gt;
            )}
          &lt;/row&gt;
        )}
      &lt;/div&gt;
    )
  }
}
</code></pre><p>如上述代码所示，<code>UserList</code> 组件按照「两个一行」的方式来显示用户列表，所以需要先将用户列表进行组合。进行组合的工作这件事情看上去是比较独立的，所以我们往往会将 <code>chunk</code> 实现成 <code>UserList</code> 的一个成员函数，在 render 中调用它。</p>
<p>我认为这样做并不可取，因为 chunk 只会被 render 所调用，仅仅服务于 render。阅读这个类源码的时候，读者其实只需要在 render 中去了解 chunk 函数就够了。然而 chunk 以成员函数的形式出现，扩大了它的可用范围，提前把自己曝光给了读者，反而会造成干扰。读者阅读源码，首先就是将代码折叠起来，然后他看到的是这样的景象：</p>
<pre><code>class UserList extends React.Component{
  componentDidMount(){...}
  componentWillUnmount(){...}
  chunk(){...}    // 读者的内心独白：这是什么鬼？
  render(){...}
}
</code></pre><p>熟悉 React 的同学对组件中出现一个不熟悉的方法多半会感到困惑。不管怎么说，读者肯定会首先去浏览一遍这些成员函数，但是阅读 <code>chunk</code> 函数带给读者的信息基本是零，反而还会干扰读者的思路，因为读者现在还不知道用户列表需要以「每两个一行」的方式呈现。所以我认为，<code>chunk</code> 函数绝对应该定义在 <code>render</code> 中，如下所示：</p>
<pre><code>render(){
  const chunk = (users) =&gt; ...
  const chunks = this.chunk(this.props.users);
  return (
    &lt;div&gt;
  ...
}
</code></pre><p>这样虽然函数的行数可能会比较多，但将代码折叠起来后，函数的逻辑则会非常清楚。而且，<code>chunk</code> 函数曝光在读者眼中的时机是非常正确的，那就是，在它即将被调用的地方。实际上，在「计算函数的代码行数」这个问题上，我会把内部定义的函数视为一行，因为函数对读者可以是黑盒，它的负担只有一行。</p>
<h2 id="-">总结</h2>
<p>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复<strong>打磨</strong>自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p>
]]></description>
            <link>http://xieguanglei.github.io/post/write-readable-code-practice.html</link>
            <guid isPermaLink="false">write-readable-code-practice</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Tue, 03 Jan 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：key 属性的原理和用法]]></title>
            <description><![CDATA[<h1 id="react-key-">React 实践心得：key 属性的原理和用法</h1>
<p>我们知道，React 元素可以具有一个特殊的属性 key，这个属性不是给用户自己用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p>
<p>如果你有下面这样的代码：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 没有提供 key
  &lt;/div&gt;
);
</code></pre>
<p>React 会在控制台打印出报警信息：</p>
<blockquote>
<p>Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of <code>App</code>. See <a href="https://fb.me/react-warning-keys">https://fb.me/react-warning-keys</a> for more information.</p>
</blockquote>
<p>你必须为数组中的元素提供唯一的 <code>key</code> 属性，就像下面这样：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div key={u.id}&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 提供了 key
  &lt;/div&gt;
);
</code></pre>
<p>为什么呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如 UserList 组件的 users 属性改变了，就得重新渲染 UserList 组件，包括外部的 <code>&lt;div&gt;</code>（容器），内部的一个 <code>&lt;h3&gt;</code> 和若干个 <code>&lt;div&gt;</code>（每一个描述一个用户）。</p>
<p>对后一种 <code>&lt;div&gt;</code>（表示用户的），由于其处在一个长度不确定的数组中，React 需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。比如以下几种情况：</p>
<ul>
<li><code>[{name: &#39;张三&#39;, age: 20}]</code> =&gt; <code>[{name: &#39;张三&#39;, age: 21}]</code>：这种情况明显只需要更新元素，没有必要重新创建元素。因为人还是那个人，除了 age，其他信息没有变，显示用户姓名的那个（更小的）元素，是不需要更新（被 ReactDOM 操作到）的。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> 这种情况，显然需要添加一个新元素来表示李四，这个新元素对应的 DOM 元素会被插入到页面中。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}]</code>：这种情况就有点复杂了，似乎两种方案都可以。可以把表示张三的元素删掉，为李四新建一个，当然是非常合理的选择。但是直接把张三的元素换成李四，似乎也无不可。</li>
</ul>
<p>实际上，如果真的认为上述第3种的后一种方案也无不可，那可是大错特错了。为什么呢：</p>
<ul>
<li>考虑这种情况：<code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}, {name: &#39;张三&#39;}]</code>，难道也需要把张三的元素更新成李四的，李四的元素更新成张三的吗？</li>
</ul>
<p>那么，为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>
<p>那么，为什么只有数组中的元素需要有唯一的 key，而其他的元素（比如上面的<code>&lt;h3&gt;用户列表&lt;/h3&gt;</code>）则不需要呢？答案是：React 有能力辨别出，更新前后元素的对应关系。这一点，也许直接看 JSX 不够明显，看 Babel 转换后的 React.createElement 则清晰很多：</p>
<pre><code class="lang-jsx">// 转换前
const element = (
  &lt;div&gt;
    &lt;h3&gt;example&lt;/h3&gt;
    {[&lt;p key={1}&gt;hello&lt;/p&gt;, &lt;p key={2}&gt;world&lt;/p&gt;]}
  &lt;/div&gt;
);

// 转换后
&quot;use strict&quot;;

var element = React.createElement(
  &quot;div&quot;,
  null,
  React.createElement(&quot;h3&quot;,null,&quot;example&quot;),
  [
    React.createElement(&quot;p&quot;,{ key: 1 },&quot;hello&quot;), 
    React.createElement(&quot;p&quot;,{ key: 2 },&quot;world&quot;)
  ]
);
</code></pre>
<p>不管 props 如何变化，数组外的每个元素始终出现在 React.createElement() 参数列表中的固定位置，这个位置就是天然的 key。</p>
<blockquote>
<p>题外话</p>
<p>初学 React 时还容易产生另一个困惑，那就是为什么 JSX 不支持 if 表达式来有选择地输出（不能这样：<code>{if(yes){ &lt;div {...props}/&gt; }}</code>），而必须采用三元运算符来完成这项工作（必须这样：<code>{yes ? &lt;div {...props}/&gt;} : null</code>）。那是因为，React 需要一个 null 去占住那个元素本来的位置。</p>
</blockquote>
<p>曾经，我天真的以为 <code>key</code> 这个元素只应在数组中使用。直到我在一个复杂的项目中写出了及其恶心的 <code>componentWillReceiveProps</code>方法。我尝试寻找销毁和重建组件，触发 <code>componentDidMount</code> 方法，重置 <code>state</code>，然后才突然发现 <code>key</code> 这个属性已经在那里了。</p>
<p>举个例子，我们有一个展示用户信息的 <code>UserDashboard</code> 组件。传给组件的 <code>props</code> 只有用户的 基本信息（ID，姓名等），而有关用户的详细信息（比如当前是否在线等）是需要请求过来的。组件内的一些操作（比如尝试与该用户聊天）也会使用请求，组件本身也有各种状态（比如是否显示聊天框）。</p>
<p>整个界面上最多只有一个 <code>UserDashboard</code>，但某些操作（比如点击旁边的 <code>UserList</code>）可能会切换 <code>UserDashboard</code> 的目标用户，那么问题就来了：当目标用户切换的时候，<code>UserDashboard</code> 仅仅是一个普通的<strong>更新</strong>操作，触发的是 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>componentDidUpdate</code> 这一套方法。我们需要在 <code>componentWillReceiveProps</code> 中做太多的事情：检测这次 props 的更新是否改变了用户的 ID，如果是的话，我们需要检查 <code>UserDashboard</code> 发出去的请求是否都得到了响应，对还未收到响应的请求注销其响应函数（否则上一个用户的在线状态有可能显示在这一个用户上）；我们还要更新 <code>UserDashboard</code> 上的几乎所有状态（切换用户的时候总要把聊天框关闭吧）；如果我们还不幸地用的 <code>ref</code> 做了一些神奇的 hack，那么你还要去手动把之前做的事情复原回来，这简直要成一团乱麻了！当 <code>UserDashborad</code> 的逻辑，你的 <code>componentWillReceiveProps</code> 方法里会充斥着晦涩难懂的只有你能看懂的代码（两周后你自己也看不懂了）。</p>
<p>解决方案是什么？就是用 <code>key</code> 属性。在 JSX 中使用 <code>UserDashboard</code> 的时候，不仅把 <code>userInfo</code> 传入，把 <code>userInfo.id</code> 作为名为 <code>key</code> 的 <code>props</code> 传入（尽管 <code>UserDashboard</code> 不是数组中的组件）。这样切换目标用户的时候，<code>key</code> 属性也变了，React 会自动销毁之前的组件，用一个全新的组件来渲染新的用户：我们可以从容地在 <code>componentWillUnmount</code> 里作清理工作（注销请求的响应函数，防止其更新一个 unmounted component），至于重置 <code>state</code> 这些工作已经不需要做了，由于组件不再是更新，而是销毁和重建，已经是天然完成的。</p>
<p>当然，你可以质疑这样做是否会影响性能。我认为，只要目标用户的切换不够频繁，对性能的影响是很小的。如果不使用 <code>key</code> 触发组件的销毁和重建，任由组件自行「更新」，每次切换时更新的内容也是很多的。这时，我们使用 <code>key</code> 带来的性能损耗是完全可以接受的，而带来的收益却非常大。</p>
<p>所以，我想说的结论是：为了组件内部逻辑的清晰，你几乎应该在任何复杂的有状态组件（尤其是有具体<strong>对应</strong>对象的）上使用<code>key</code>属性（只要 <code>key</code> 属性的改变不是很频繁），这样做，才能在合适的时候触发组件的销毁与重建，组件才能有一个健康的生命周期。</p>
<blockquote>
<p>题外话</p>
<p>配合 react-router 时，通常要为 route 组件赋 key，但通常情况下我们是没法传 props 给 route 组件的。解决的方案是 <code>createElement</code> 方法，如下所示。</p>
<pre><code>class App extends Component {
  static createElement = (Component, ownProps) =&gt; {
    const {userId} = ownProps.params;
    switch (Component) {
      case UserDashboard:
        return &lt;Component key={userId} {...ownProps}/&gt;;
      default:
        return &lt;Component {...ownProps}/&gt;;
    }
  };
  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;Router createElement={App.createElement} 
                history={syncHistoryWithStore(hashHistory, store)}&gt;
          &lt;Route path=&quot;/&quot; component={Home}&gt;
            &lt;IndexRoute component={Index}/&gt;
            &lt;Route path=&quot;users/:userId&quot; component={UserDashboard}/&gt;
          &lt;/Route&gt;
        &lt;/Router&gt;
      &lt;/Provider&gt;
    )
  }
}
</code></pre></blockquote>
<p>（完）</p>
]]></description>
            <link>http://xieguanglei.github.io/post/react-tips-key.html</link>
            <guid isPermaLink="false">react-tips-key</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Mon, 15 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：react-redux 之 connect 方法详解]]></title>
            <description><![CDATA[<h1 id="react-react-redux-connect-">React 实践心得：react-redux 之 connect 方法详解</h1>
<p>Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。</p>
<p>react-redux 提供了两个重要的对象，<code>Provider</code> 和 <code>connect</code>，前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对 <code>connect</code> 的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。</p>
<p>在使用了一段时间 redux 后，本文尝试再次回到这里，给<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">这段文档</a>（同时摘抄在附录中）一个靠谱的解读。</p>
<h2 id="-">预备知识</h2>
<p>首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去<a href="https://github.com/reactjs/redux/blob/master/docs/README.md">阅读一下</a>。</p>
<pre><code class="lang-jsx">const reducer = (state = {count: 0}, action) =&gt; {
  switch (action.type){
    case &#39;INCREASE&#39;: return {count: state.count + 1};
    case &#39;DECREASE&#39;: return {count: state.count - 1};
    default: return state;
  }
}

const actions = {
  increase: () =&gt; ({type: &#39;INCREASE&#39;}),
  decrease: () =&gt; ({type: &#39;DECREASE&#39;})
}

const store = createStore(reducer);

store.subscribe(() =&gt;
  console.log(store.getState())
);

store.dispatch(actions.increase()) // {count: 1}
store.dispatch(actions.increase()) // {count: 2}
store.dispatch(actions.increase()) // {count: 3}
</code></pre>
<p>通过 <code>reducer</code> 创建一个 <code>store</code>，每当我们在 <code>store</code> 上 <code>dispatch</code> 一个 <code>action</code>，<code>store</code> 内的数据就会相应地发生变化。</p>
<p>我们当然可以<strong>直接</strong>在 React 中使用 Redux：在最外层容器组件中初始化 <code>store</code>，然后将 <code>state</code> 上的属性作为 <code>props</code> 层层传递下去。</p>
<pre><code class="lang-jsx">class App extends Component{

  componentWillMount(){
    store.subscribe((state)=&gt;this.setState(state))
  }

  render(){
    return &lt;Comp state={this.state}
                 onIncrease={()=&gt;store.dispatch(actions.increase())}
                 onDecrease={()=&gt;store.dispatch(actions.decrease())}
    /&gt;
  }
}
</code></pre>
<p>但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的 <code>Provider</code> 和 <code>connect</code> 方法。</p>
<h2 id="-react-redux">使用 react-redux</h2>
<p>首先在最外层容器中，把所有内容包裹在 <code>Provider</code> 组件中，将之前创建的 <code>store</code> 作为 <code>prop</code> 传给 <code>Provider</code>。</p>
<pre><code class="lang-jsx">const App = () =&gt; {
  return (
    &lt;Provider store={store}&gt;
      &lt;Comp/&gt;
    &lt;/Provider&gt;
  )
};
</code></pre>
<p><code>Provider</code> 内的任何一个组件（比如这里的 <code>Comp</code>），如果需要使用 <code>state</code> 中的数据，就必须是「被 connect 过的」组件——使用 <code>connect</code> 方法对「你编写的组件（<code>MyComp</code>）」进行包装后的产物。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  // content...
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>可见，<code>connect</code> 方法是重中之重。</p>
<h2 id="-connect-"><code>connect</code> 详解</h2>
<p>究竟 <code>connect</code> 方法到底做了什么，我们来一探究竟。</p>
<p>首先看下函数的签名：</p>
<blockquote>
<p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
</blockquote>
<p><code>connect()</code> 接收四个参数，它们分别是 <code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>和<code>options</code>。</p>
<h3 id="-mapstatetoprops-state-ownprops-stateprops-"><code>mapStateToProps(state, ownProps) : stateProps</code></h3>
<p>这个函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    count: state.count
  }
}
</code></pre>
<p>这个函数的第一个参数就是 Redux 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>MyComp</code> 会有名为 <code>count</code> 的 <code>props</code> 字段。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  render(){
    return &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
  }
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>当然，你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    greaterThanFive: state.count &gt; 5
  }
}
</code></pre>
<p>函数的第二个参数 <code>ownProps</code>，是 <code>MyComp</code> 自己的 <code>props</code>。有的时候，<code>ownProps</code> 也会对其产生影响。比如，当你在 <code>store</code> 中维护了一个用户列表，而你的组件 <code>MyComp</code> 只关心一个用户（通过 <code>props</code> 中的 <code>userId</code> 体现）。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state, ownProps) =&gt; {
  // state 是 {userList: [{id: 0, name: &#39;王二&#39;}]}
  return {
    user: _.find(state.userList, {id: ownProps.userId})
  }
}

class MyComp extends Component {

  static PropTypes = {
    userId: PropTypes.string.isRequired,
    user: PropTypes.object
  };

  render(){
    return &lt;div&gt;用户名：{this.props.user.name}&lt;/div&gt;
  }
}

const Comp = connect(mapStateToProps)(MyComp);
</code></pre>
<p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。</p>
<p>这就是将 Redux <code>store</code> 中的数据连接到组件的基本方式。</p>
<h3 id="-mapdispatchtoprops-dispatch-ownprops-dispatchprops-"><code>mapDispatchToProps(dispatch, ownProps): dispatchProps</code></h3>
<p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 action 作为 <code>props</code> 绑定到 <code>MyComp</code> 上。</p>
<pre><code class="lang-jsx">const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return {
    increase: (...args) =&gt; dispatch(actions.increase(...args)),
    decrease: (...args) =&gt; dispatch(actions.decrease(...args))
  }
}

class MyComp extends Component {
  render(){
    const {count, increase, decrease} = this.props;
    return (&lt;div&gt;
      &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
      &lt;button onClick={increase}&gt;增加&lt;/button&gt;
      &lt;button onClick={decrease}&gt;减少&lt;/button&gt;
    &lt;/div&gt;)
  }
}

const Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);
</code></pre>
<p>由于 <code>mapDispatchToProps</code> 方法返回了具有 <code>increase</code> 属性和 <code>decrease</code> 属性的对象，这两个属性也会成为 <code>MyComp</code> 的 <code>props</code>。</p>
<p>如上所示，调用 <code>actions.increase()</code> 只能得到一个 <code>action</code> 对象 <code>{type:&#39;INCREASE&#39;}</code>，要触发这个 <code>action</code> 必须在 <code>store</code> 上调用 <code>dispatch</code> 方法。<code>diapatch</code> 正是 <code>mapDispatchToProps</code> 的第一个参数。但是，为了不让 <code>MyComp</code> 组件感知到 <code>dispatch</code> 的存在，我们需要将 <code>increase</code> 和 <code>decrease</code> 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 <code>dispatch</code>）。</p>
<p>Redux 本身提供了 <code>bindActionCreators</code> 函数，来将 action 包装成直接可被调用的函数。</p>
<pre><code class="lang-jsx">import {bindActionCreators} from &#39;redux&#39;;

const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return bindActionCreators({
    increase: action.increase,
    decrease: action.decrease
  });
}
</code></pre>
<p>同样，当 <code>ownProps</code> 变化的时候，该函数也会被调用，生成一个新的 <code>dispatchProps</code>，（在与 <code>statePrope</code> 和 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。注意，<code>action</code> 的变化不会引起上述过程，默认 <code>action</code> 在组件的生命周期中是固定的。</p>
<h3 id="-mergeprops-stateprops-dispatchprops-ownprops-props-"><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></h3>
<p>之前说过，不管是 <code>stateProps</code> 还是 <code>dispatchProps</code>，都需要和 <code>ownProps</code> merge 之后才会被赋给 <code>MyComp</code>。<code>connect</code> 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，<code>connect</code> 就会使用 <code>Object.assign</code> 替代该方法。</p>
<h3 id="-">其他</h3>
<p>最后还有一个 <code>options</code> 选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。</p>
<p>（完）</p>
<h2 id="-connect-">附：connect 方法的官方英文文档</h2>
<blockquote>
<h4 id="-connect-mapstatetoprops-mapdispatchtoprops-mergeprops-options-"><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h4>
<p>Connects a React component to a Redux store.</p>
<p>It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function): If specified, the component will subscribe to Redux store updates. Any time it updates, mapStateToProps will be called. Its result must be a plain object*, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).</p>
</li>
<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.</p>
</li>
<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.</p>
</li>
<li><p>[options] (Object) If specified, further customizes the behavior of the connector.</p>
<ul>
<li>[pure = true] (Boolean): If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Defaults to true.</li>
<li>[withRef = false] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Defaults to false.</li>
</ul>
</li>
</ul>
</blockquote>
]]></description>
            <link>http://xieguanglei.github.io/post/react-tips-connect.html</link>
            <guid isPermaLink="false">react-tips-connect</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Sun, 14 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：说说 children 的使用]]></title>
            <description><![CDATA[<h1 id="react-children-">React 实践心得：说说 children 的使用</h1>
<p>React 的初学者通常会犯一个错误是：不大会使用（甚至完全不使用）组件的 children 属性。其实，对 children 的合理使用，是「组件化」的基础。</p>
<p>这篇短文就通过一个例子，说说应该怎样合理地使用 children。</p>
<p>假设我们要做下图所示的一个用户列表组件：具体要求是这样的：</p>
<ul>
<li>顶部有「用户列表」的字样。</li>
<li>用户列表中应显示用户的头像，名称，描述，还有一个关注按钮。</li>
<li>用户的描述信息默认不显示，鼠标 hover 到用户头像上时，用气泡显示描述信息。</li>
<li>点击「关注」按钮即可关注用户，随之按钮文案变成「取关」（取消关注）。</li>
</ul>
<p><img src="https://img.alicdn.com/tps/TB1_AceLXXXXXXHXpXXXXXXXXXX-200-271.png" alt="原型图"></p>
<p>首先拆解一下上面的原型：</p>
<ul>
<li>我们首先需要一个用户列表 UserList，它在最外层。</li>
<li>UserList 组件中有一组用户信息组件 UserItem。</li>
<li>用户信息组件包括头像 Avatar，名字 Name，描述 Description，关注按钮 FollowButton。</li>
</ul>
<p><img src="https://img.alicdn.com/tps/TB1OU.rLXXXXXXBXFXXXXXXXXXX-754-415.png" alt=""></p>
<p><code>UserList</code> 会被其外层容器组件调用。如果你对 React 和「组件化」思想比较缺乏经验，很有可能会写出这样的代码来。</p>
<pre><code class="lang-js">// 不好的实现
// UserList 的外层容器组件
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [{
        id: &#39;001&#39;,
        name: &#39;关羽&#39;,
        description: &#39;斩颜良诛文丑巴拉巴拉&#39;,
        avatar: &#39;https://关羽的自画像.jpg&#39;,
        followed: false  // 是否已关注
      }, ...otherUsers]
    }
  }

  doToggleFollow(id) {
    // 关注、取消关注的请求
    requestToggleFollow(id, ()=&gt;{
      const users = _.clone(this.state.users);
      const user = _.find(users, {id});
      user.followed = !user.followed;
      this.setState({users});
    })
  }

  render() {
    return (&lt;div&gt;
      &lt;UserList users={this.state.users}
                onToggleFollow={id=&gt;this.doToggleFollow(id)}
      /&gt;
    &lt;/div&gt;)
  }
}
</code></pre>
<p>用户的数据，通常是在较外层的容器维护（这里在 <code>App</code> 组件的 <code>state</code> 下），虽然现在只有 <code>UserList</code> 用到了用户数据，但如果 App 下还有其他组件，它们几乎也一定会使用这份数据。</p>
<p>总之，现在看上去好像没有什么问题。我们使用了一个「封装良好」的 <code>UserList</code> 组件，这个组件负责搞定用户列表组件内的所有事情。如果你比较敏感的话，你可能会觉得把 <code>onToggleFollow</code> 方法传给 <code>UserList</code> 这件事似乎有些不妥，那又怎样，总之 <code>render</code> 方法看上去很干净，不是吗？</p>
<p>下面我们来看 <code>UserList</code> 的实现。</p>
<pre><code class="lang-js">// 不好的实现
const UserList = props =&gt; {
  const {users, onToggleFollow} = props;
  return (
    &lt;div&gt;
      &lt;h3&gt;用户列表&lt;/h3&gt;
      {
        users.map((u, i)=&gt;
          &lt;div key={i}&gt;
            &lt;UserItem user={u} onToggleFollow={onToggleFollow}/&gt;
          &lt;/div&gt;
        )
      }
    &lt;/div&gt;
  )
};
</code></pre>
<p>我们把从外面传过来的 <code>onToggleFollow</code> 继续向里传递给了 <code>UserItem</code> 组件。虽然有点小不爽，但是我忍了！看 <code>UserItem</code> 的实现：</p>
<pre><code class="lang-js">// 不好的实现
class UserItem extends Component {
  constructor(props){
    super(props);
    this.state = {
      hover: false
    }
  }

  render() {
    const {user, onToggleFollow} = this.props;
    return (
      &lt;div&gt;
        &lt;Avatar src={user.avatar}
                onMouseEnter={()=&gt;this.setState({hover: true})}
                onMouseLeave={()=&gt;this.setState({hover: false})}
        /&gt;
        &lt;Name value={user.name}/&gt;
        &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;onToggleFollow(user.id)}/&gt;
        {this.state.hover ? &lt;Description value={user.description}/&gt; : null}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p><code>UserItem</code> 有一个状态 <code>hover</code>，表示用户的鼠标是否悬浮在头像上方。这个状态也用来判断是否显示用户的介绍 <code>Description</code> 组件。</p>
<p><code>onToggleFollow</code> 方法继续向下传递，实在是有点忍不了了！</p>
<p>最后我们看下最底层，最简单的这几个组件：<code>Avatar</code>，<code>Name</code>，<code>FollowButton</code> 和 <code>Description</code>。</p>
<pre><code class="lang-js">// 不好的实现

// user-item-avatar.js
class Avatar extends React.Component {
  componentDidMount(){
    const img = this.refs.img;
    img.addEventListener(&#39;mouseenter&#39;, this.props.onMouseEnter);
    img.addEventListener(&#39;mouseleave&#39;, this.props.onMouseLeave);
  }
  render() {
    return &lt;img ref=&quot;img&quot; src={this.props.src}/&gt;
  }
}

// user-item-name.js
const Name = props =&gt; &lt;div&gt;{props.value}&lt;/div&gt;;

// user-item-follow-button.js
const FollowButton = props =&gt; (
  &lt;button onClick={props.onClick}&gt;{props.isFollowing ? &#39;取消关注&#39; : &#39;关注&#39;}&lt;/button&gt;
);

// user-item-description.js
const Description = props =&gt; &lt;div&gt;{props.value}&lt;/div&gt;;
</code></pre>
<p>我们可以看到，<code>onToggleFollow</code> 方法从最外层的 <code>App</code> 组件开始向内传递，经过 <code>UserList</code> 和 <code>UserItem</code>，最终落在了 <code>FollowButton</code> 上。其实，这个行为（关注与否）与中间的两层组件 <code>UserList</code> 和 <code>UserItem</code> 并没有什么关系，如果某一天「关注」按钮变成了「发信」按钮，<code>UserList</code> 和 <code>UserItem</code> 不应该为此作任何修改。</p>
<p><img src="https://img.alicdn.com/tps/TB1jPQqLXXXXXXSXFXXXXXXXXXX-714-206.png" alt=""></p>
<p>也就是说，上面的这个 <code>UserList</code> 看上去把用户列表内的逻辑都封装了起来，但它并不是一个足够「组件化」的组件。一个合格的「组件化」的 <code>UserList</code> 应该能像下面这样被调用。</p>
<pre><code class="lang-js">// UserList 的外层容器组件
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [{
        id: &#39;001&#39;,
        name: &#39;关羽&#39;,
        description: &#39;斩颜良诛文丑巴拉巴拉&#39;,
        avatar: &#39;https://关羽的自画像.jpg&#39;,
        followed: false  // 是否已关注
      }, ...otherUsers]
    }
  }

  doToggleFollow(id) {
    // 关注、取消关注的请求
    requestToggleFollow(id, ()=&gt;{
      const users = _.clone(this.state.users);
      const user = _.find(users, {id});
      user.followed = !user.followed;
      this.setState({users});
    })
  }

  render() {
    return (&lt;div&gt;
        &lt;UserList&gt;{
          users.map((user, i) =&gt;
            &lt;UserItem key={i}&gt;
              &lt;Avatar src={user.avatar}/&gt;
              &lt;Name&gt;{user.name}&lt;/Name&gt;
              &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;this.doToggleFollow(user.id)}/&gt;
              &lt;Description&gt;{user.description}&lt;/Description&gt;
            &lt;/UserItem&gt;
          )
        }&lt;/UserList&gt;
    &lt;/div&gt;)
  }
}
</code></pre>
<p>对比上述两种 <code>UserList</code> 的用法，可见前者的用法虽然简单，但对调用者而言，却像一个令人不安的「黑盒子」，完全不知道 <code>UserList</code> 会在内部干出什么事情来，而且还需要传一个莫名其妙的 <code>onToggleFollow</code> 函数。</p>
<p>相较之下，后者的用法虽然看上去复杂一些，但是对调用者来说，组件内部的结构更加清晰，也更容易掌控。数据和行为都显而易见地绑定在与之直接关联的组件上，用户根本不需要查看 <code>UserList</code> 的实现代码就能很清楚地知道，这个组件的真正功能。</p>
<p>而这两种组件的差别，最表面的就是是否使用了 <code>children</code> 属性。</p>
<pre><code class="lang-js">// 第一种用法
render() {
  return (&lt;div&gt;
    &lt;UserList users={this.state.users}
              onToggleFollow={id=&gt;this.doToggleFollow(id)}
    /&gt;
  &lt;/div&gt;)
}

// 第二种用法
render() {
  return (&lt;div&gt;
    &lt;UserList&gt;{
      users.map((user, i) =&gt;
        &lt;UserItem key={i}&gt;
          &lt;Avatar src={user.avatar}/&gt;
          &lt;Name&gt;{user.name}&lt;/Name&gt;
          &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;this.doToggleFollow(user.id)}/&gt;
          &lt;Description&gt;{user.description}&lt;/Description&gt;
        &lt;/UserItem&gt;
      )
    }&lt;/UserList&gt;
  &lt;/div&gt;)
}
</code></pre>
<p>实现第二种 <code>UserList</code>，需要在渲染组件的时候，在特定的「坑位」上加上 <code>this.props.children</code>。如下所示：</p>
<pre><code class="lang-js">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {this.props.children}
  &lt;/div&gt;
);
</code></pre>
<p><code>UserItem</code> 相对会复杂一些：</p>
<pre><code class="lang-js">class UserItem extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hover: false
    }
  }

  render() {
    const {children: [avatar, name, followButton, description]} = this.props;
    const onMouseEnter = () =&gt; this.setState({hover: true});
    const onMouseLeave = () =&gt; this.setState({hover: false});
    return (
      &lt;div&gt;
        {React.cloneElement(avatar, {onMouseEnter, onMouseLeave})}
        {name}
        {followButton}
        {this.state.hover ? description : null}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>由于我们在 <code>UserItem</code> 内部放了多个组件，所以在 <code>UserItem</code> 中，<code>children</code> 是一个数组，需要对数组中的每一个元素进行额外处理。</p>
<p>第1个元素是头像 <code>avatar</code>，它的 hover 状态影响到用户描述的显示与否，所以需要在这一步绑定事件。但是 ReactElemnt 是不可改变（immutable）的，我们使用 <code>React.cloneElement</code> 创建了一个新的 ReactElement。</p>
<p>第4个元素的显示与否，取决于 <code>state.hover</code>，十分合理。</p>
<p>最后，我们可以总结一下，<code>UserList</code> 组件对于用户的直观感受：</p>
<p>第一种实现：</p>
<ul>
<li>用户列表 UserList：<ul>
<li>需要传入用户数据（用户数据里的结构不大清楚）。</li>
<li>还需要传入一个不知干什么的函数（研究了一下，应该是点击关注按钮后调用）。</li>
</ul>
</li>
</ul>
<p>第二种实现：</p>
<ul>
<li>用户列表 UserList：<ul>
<li>其中包括 UserItem 的列表。</li>
</ul>
</li>
<li>用户信息 UserItem：<ul>
<li>包括用户头像 Avatar，数据来源于 user.avatar。</li>
<li>包括用户名字 Name，数据来源于 user.name。</li>
<li>包括一个按钮 FollowButton，需要设定 user.isFollowing 状态，用户点击后调用函数进行关注/取关。</li>
<li>包括用户描述 Description，数据来源于 user.description。</li>
<li>发现只有鼠标 hover 在头像上时才会显示出来，但是我可以不需要关心这件事。</li>
</ul>
</li>
</ul>
<p>很显然，上面的第二种实现方案确实比第一种的质量高很多。</p>
]]></description>
            <link>http://xieguanglei.github.io/post/react-tips-children.html</link>
            <guid isPermaLink="false">react-tips-children</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Thu, 04 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Canvas 最佳实践（性能篇）]]></title>
            <description><![CDATA[<h1 id="canvas-">Canvas 最佳实践（性能篇）</h1>
<p>Canvas 想必前端同学们都不陌生，它是 HTML5 新增的「画布」元素，允许我们使用 JavaScript 来绘制图形。目前，所有的主流浏览器都支持 Canvas。</p>
<p><img src="http://img.alicdn.com/tps/TB1YgYILpXXXXcXXFXXXXXXXXXX-764-261.jpg" alt="Canvas兼容性"></p>
<p>Canvas 最常见的用途是渲染动画。渲染动画的基本原理，无非是反复地擦除和重绘。为了动画的流畅，留给我渲染一帧的时间，只有短短的 16ms。在这 16ms 中，我不仅需要处理一些游戏逻辑，计算每个对象的位置、状态，还需要把它们都画出来。如果消耗的时间稍稍多了一些，用户就会感受到「卡顿」。所以，在编写动画（和游戏）的时候，我无时无刻不担忧着动画的性能，唯恐对某个 API 的调用过于频繁，导致渲染的耗时延长。</p>
<p>为此，我做了一些实验，查阅了一些资料，整理了平时使用 Canvas 的若干心得体会，总结出这一片所谓的「最佳实践」。如果你和我有类似的困扰，希望本文对你有一些价值。</p>
<blockquote>
<p>本文仅讨论 Canvas 2D 相关问题。</p>
</blockquote>
<h1 id="-">计算与渲染</h1>
<p>把动画的一帧渲染出来，需要经过以下步骤：</p>
<ol>
<li>计算：处理游戏逻辑，计算每个对象的状态，不涉及 DOM 操作（当然也包含对 Canvas 上下文的操作）。</li>
<li>渲染：真正把对象绘制出来。
2.1. JavaScript 调用 DOM API（包括 Canvas API）以进行渲染。
2.2. 浏览器（通常是另一个渲染线程）把渲染后的结果呈现在屏幕上的过程。</li>
</ol>
<p><img src="http://img.alicdn.com/tps/TB1i6rMLpXXXXaZXFXXXXXXXXXX-593-323.png" alt=""></p>
<blockquote>
<p>之前曾说过，留给我们渲染每一帧的时间只有 16ms。然而，其实我们所做的只是上述的步骤中的 1 和 2.1，而步骤 2.2 则是浏览器在另一个线程（至少几乎所有现代浏览器是这样的）里完成的。动画流畅的真实前提是，以上所有工作都在 16ms 中完成，所以 JavaScript 层面消耗的时间最好控制在 10ms 以内。</p>
</blockquote>
<p>虽然我们知道，通常情况下，渲染比计算的开销大很多（3~4个量级）。除非我们用到了一些时间复杂度很高的算法（这一点在本文最后一节讨论），计算环节的优化没有必要深究。</p>
<p>我们需要深入研究的，是如何优化渲染的性能。而优化渲染性能的总体思路很简单，归纳为以下几点：</p>
<ol>
<li>在每一帧中，尽可能减少调用渲染相关 API 的次数（通常是以计算的复杂化为代价的）。</li>
<li>在每一帧中，尽可能调用那些渲染开销较低的 API。</li>
<li>在每一帧中，尽可能以「导致渲染开销较低」的方式调用渲染相关 API。</li>
</ol>
<h1 id="canvas-">Canvas 上下文是状态机</h1>
<p>Canvas API 都在其上下文对象 <code>context</code> 上调用。</p>
<pre><code class="lang-javascript">var context = canvasElement.getContext(&#39;2d&#39;);
</code></pre>
<p>我们需要知道的第一件事就是，<code>context</code> 是一个状态机。你可以改变 <code>context</code> 的若干状态，而几乎所有的渲染操作，最终的效果与 <code>context</code> 本身的状态有关系。比如，调用 <code>strokeRect</code> 绘制的矩形边框，边框宽度取决于 <code>context</code> 的状态 <code>lineWidth</code>，而后者是之前设置的。</p>
<pre><code class="lang-javascript">context.lineWidth = 5;
context.strokeColor = &#39;rgba(1, 0.5, 0.5, 1)&#39;;

context.strokeRect(100, 100, 80, 80);
</code></pre>
<p><img src="http://img.alicdn.com/tps/TB1M4vNLpXXXXarXFXXXXXXXXXX-407-348.png" alt=""></p>
<p>说到这里，和性能貌似还扯不上什么关系。那我现在就要告诉你，对 <code>context.lineWidth</code> 赋值的开销远远大于对一个普通对象赋值的开销，你会作如何感想。</p>
<p>当然，这很容易理解。Canvas 上下文不是一个普通的对象，当你调用了 <code>context.lineWidth = 5</code> 时，浏览器会需要立刻地做一些事情，这样你下次调用诸如 <code>stroke</code> 或 <code>strokeRect</code> 等 API 时，画出来的线就正好是 5 个像素宽了（不难想象，这也是一种优化，否则，这些事情就要等到下次 <code>stroke</code> 之前做，更加会影响性能）。</p>
<p>我尝试执行以下赋值操作 10<sup>6</sup> 次，得到的结果是：对一个普通对象的属性赋值只消耗了 3ms，而对 <code>context</code> 的属性赋值则消耗了 40ms。值得注意的是，如果你赋的值是非法的，浏览器还需要一些额外时间来处理非法输入，正如第三/四种情形所示，消耗了 140ms 甚至更多。</p>
<pre><code>somePlainObject.lineWidth = 5;  // 3ms (10^6 times)
context.lineWidth = 5;  // 40ms
context.lineWidth = &#39;Hello World!&#39;; // 140ms
context.lineWidth = {}; // 600ms
</code></pre><p>对 <code>context</code> 而言，对不同属性的赋值开销也是不同的。<code>lineWidth</code> 只是开销较小的一类。下面整理了为 <code>context</code> 的一些其他的属性赋值的开销，如下所示。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>开销</th>
<th>开销（非法赋值）</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>line[Width/Join/Cap]</code></td>
<td>40+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>[fill/stroke]Style</code></td>
<td>100+</td>
<td>200+</td>
</tr>
<tr>
<td> <code>font</code></td>
<td>1000+</td>
<td>1000+</td>
</tr>
<tr>
<td> <code>text[Align/Baseline]</code></td>
<td>60+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>shadow[Blur/OffsetX]</code></td>
<td>40+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>shadowColor</code></td>
<td>280+</td>
<td>400+</td>
</tr>
</tbody>
</table>
<p>与真正的绘制操作相比，改变 <code>context</code> 状态的开销已经算比较小了，毕竟我们还没有真正开始绘制操作。我们需要了解，改变 <code>context</code> 的属性并非是完全无代价的。我们可以通过适当地安排调用绘图 API 的顺序，降低 <code>context</code> 状态改变的频率。</p>
<h1 id="-canvas">分层 Canvas</h1>
<p>分层 Canvas 在几乎任何动画区域较大，动画较复杂的情形下都是非常有必要的。分层 Canvas 能够大大降低完全不必要的渲染性能开销。分层渲染的思想被广泛用于图形相关的领域：从古老的皮影戏、套色印刷术，到现代电影/游戏工业，虚拟现实领域，等等。而分层 Canvas 只是分层渲染思想在 Canvas 动画上最最基本的应用而已。</p>
<p><img src="http://img.alicdn.com/tps/TB1RgLULpXXXXatXVXXXXXXXXXX-667-309.png" alt="分层Canvas"></p>
<p>分层 Canvas 的出发点是，动画中的每种元素（层），对渲染和动画的要求是不一样的。对很多游戏而言，主要角色变化的频率和幅度是很大的（他们通常都是走来走去，打打杀杀的），而背景变化的频率或幅度则相对较小（基本不变，或者缓慢变化，或者仅在某些时机变化）。很明显，我们需要很频繁地更新和重绘人物，但是对于背景，我们也许只需要绘制一次，也许只需要每隔 200ms 才重绘一次，绝对没有必要每 16ms 就重绘一次。</p>
<blockquote>
<p>对于 Canvas 而言，能够在每层 Canvas 上保持不同的重绘频率已经是最大的好处了。然而，分层思想所解决的问题远不止如此。</p>
</blockquote>
<p>使用上，分层 Canvas 也很简单。我们需要做的，仅仅是生成多个 Canvas 实例，把它们重叠放置，每个 Canvas 使用不同的 z-index 来定义堆叠的次序。然后仅在需要绘制该层的时候（也许是「永不」）进行重绘。</p>
<pre><code class="lang-javascript">var contextBackground = canvasBackground.getContext(&#39;2d&#39;);
var contextForeground = canvasForeground.getContext(&#39;2d&#39;);

function render(){
  drawForeground(contextForeground);
  if(needUpdateBackground){
    drawBackground(contextBackground);
  }
  requestAnimationFrame(render);
}
</code></pre>
<p>记住，堆叠在上方的 Canvas 中的内容会覆盖住下方 Canvas 中的内容。</p>
<h1 id="-">绘制图像</h1>
<p>目前，Canvas 中使用到最多的 API，非 <code>drawImage</code> 莫属了。（当然也有例外，你如果要用 Canvas 写图表，自然是半句也不会用到了）。</p>
<p><code>drawImage</code> 方法的格式如下所示：</p>
<pre><code>context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
</code></pre><p><img src="http://gw.alicdn.com/tps/TB11l3dLpXXXXXRXpXXXXXXXXXX-593-395.png" alt=""></p>
<h2 id="-">数据源与绘制的性能</h2>
<p>由于我们具备「把图片中的某一部分绘制到 Canvas 上」的能力，所以很多时候，我们会把多个游戏对象放在一张图片里面，以减少请求数量。这通常被称为「精灵图」。然而，这实际上存在着一些潜在的性能问题。我发现，使用 <code>drawImage</code> 绘制同样大小的区域，数据源是一张和绘制区域尺寸相仿的图片的情形，比起数据源是一张较大图片（我们只是把数据扣下来了而已）的情形，前者的开销要小一些。可以认为，两者相差的开销正是「裁剪」这一个操作的开销。</p>
<blockquote>
<p>我尝试绘制 10<sup>4</sup> 次一块 320x180 的矩形区域，如果数据源是一张 320x180 的图片，花费了 40ms，而如果数据源是一张 800x800 图片中裁剪出来的 320x180 的区域，需要花费 70ms。</p>
</blockquote>
<p>虽然看上去开销相差并不多，但是 <code>drawImage</code> 是最常用的 API 之一，我认为还是有必要进行优化的。优化的思路是，将「裁剪」这一步骤事先做好，保存起来，每一帧中仅绘制不裁剪。具体的，在「离屏绘制」一节中再详述。</p>
<h2 id="-">视野之外的绘制</h2>
<p>有时候，Canvas 只是游戏世界的一个「窗口」，如果我们在每一帧中，都把整个世界全部画出来，势必就会有很多东西画到 Canvas 外面去了，同样调用了绘制 API，但是并没有任何效果。我们知道，判断对象是否在 Canvas 中会有额外的计算开销（比如需要对游戏角色的全局模型矩阵求逆，以分解出对象的世界坐标，这并不是一笔特别廉价的开销），而且也会增加代码的复杂程度，所以关键是，是否值得。</p>
<p>我做了一个实验，绘制一张 320x180 的图片 10<sup>4</sup> 次，当我每次都绘制在 Canvas 内部时，消耗了 40ms，而每次都绘制在 Canvas 外时，仅消耗了 8ms。大家可以掂量一下，考虑到计算的开销与绘制的开销相差 2~3 个数量级，我认为通过计算来过滤掉哪些画布外的对象，仍然是很有必要的。</p>
<h1 id="-">离屏绘制</h1>
<p>上一节提到，绘制同样的一块区域，如果数据源是尺寸相仿的一张图片，那么性能会比较好，而如果数据源是一张大图上的一部分，性能就会比较差，因为每一次绘制还包含了裁剪工作。也许，我们可以先把待绘制的区域裁剪好，保存起来，这样每次绘制时就能轻松很多。</p>
<p><code>drawImage</code> 方法的第一个参数不仅可以接收 <code>Image</code> 对象，也可以接收另一个 <code>Canvas</code> 对象。而且，使用 <code>Canvas</code> 对象绘制的开销与使用 <code>Image</code> 对象的开销几乎完全一致。我们只需要实现将对象绘制在一个未插入页面的 <code>Canvas</code> 中，然后每一帧使用这个 <code>Canvas</code> 来绘制。</p>
<pre><code class="lang-js">// 在离屏 canvas 上绘制
var canvasOffscreen = document.createElement(&#39;canvas&#39;);
canvasOffscreen.width = dw;
canvasOffscreen.height = dh;
canvasOffscreen.getContext(&#39;2d&#39;).drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

// 在绘制每一帧的时候，绘制这个图形
context.drawImage(canvasOffscreen, x, y);
</code></pre>
<p>离屏绘制的好处远不止上述。有时候，游戏对象是多次调用 <code>drawImage</code> 绘制而成，或者根本不是图片，而是使用路径绘制出的矢量形状，那么离屏绘制还能帮你把这些操作简化为一次 <code>drawImage</code> 调用。</p>
<blockquote>
<p>第一次看到 <code>getImageData</code> 和 <code>putImageData</code> 这一对 API，我有一种错觉，它们简直就是为了上面这个场景而设计的。前者可以将某个 Canvas 上的某一块区域保存为 <code>ImageData</code> 对象，后者可以将 <code>ImageData</code> 对象重新绘制到 Canvas 上面去。但实际上，<code>putImageData</code> 是一项开销极为巨大的操作，它根本就不适合在每一帧里面去调用。</p>
</blockquote>
<h1 id="-">避免「阻塞」</h1>
<p>所谓「阻塞」，可以理解为不间断运行时间超过 16ms 的 JavaScript 代码，以及「导致浏览器花费超过 16ms 时间进行处理」的 JavaScript 代码。即使在没有什么动画的页面里，阻塞也会被用户立刻察觉到：阻塞会使页面上的对象失去响应——按钮按不下去，链接点不开，甚至标签页都无法关闭了。而在包含较多 JavaScript 动画的页面里，阻塞会使动画停止一段时间，直到阻塞恢复后才继续执行。如果经常出现「小型」的阻塞（比如上述提及的这些优化没有做好，渲染一帧的时间超过 16ms），那么就会出现「丢帧」的情况，</p>
<blockquote>
<p>CSS3 动画（<code>transition</code> 与 <code>animate</code>）不会受 JavaScript 阻塞的影响，但不是本文讨论的重点。</p>
</blockquote>
<p><img src="http://img.alicdn.com/tps/TB18QnWLpXXXXapXVXXXXXXXXXX-674-461.png" alt=""></p>
<p>偶尔的且较小的阻塞是可以接收的，频繁或较大的阻塞是不可以接受的。也就是说，我们需要解决两种阻塞：</p>
<ul>
<li>频繁（通常较小）的阻塞。其原因主要是过高的渲染性能开销，在每一帧中做的事情太多。</li>
<li>较大（虽然偶尔发生）的阻塞。其原因主要是运行复杂算法、大规模的 DOM 操作等等。</li>
</ul>
<p>对前者，我们应当仔细地优化代码，有时不得不降低动画的复杂（炫酷）程度，本文前几节中的优化方案，解决的就是这个问题。</p>
<p>而对于后者，主要有以下两种优化的策略。</p>
<ul>
<li>使用 Web Worker，在另一个线程里进行计算。</li>
<li>将任务拆分为多个较小的任务，插在多帧中进行。</li>
</ul>
<p>Web Worker 是好东西，性能很好，兼容性也不错。浏览器用另一个线程来运行 Worker 中的 JavaScript 代码，完全不会阻碍主线程的运行。动画（尤其是游戏）中难免会有一些时间复杂度比较高的算法，用 Web Worker 来运行再合适不过了。</p>
<p><img src="http://img.alicdn.com/tps/TB1qt_yLpXXXXcrXVXXXXXXXXXX-764-277.jpg" alt="Web Worker 兼容性"></p>
<p>然而，Web Worker 无法对 DOM 进行操作。所以，有些时候，我们也使用另一种策略来优化性能，那就是将任务拆分成多个较小的任务，依次插入每一帧中去完成。虽然这样做几乎肯定会使执行任务的总时间变长，但至少动画不会卡住了。</p>
<p><img src="http://gw.alicdn.com/tps/TB1UG.qLpXXXXbdXpXXXXXXXXXX-674-461.png" alt=""></p>
<p>看下面这个 <a href="http://jsbin.com/puruba/edit?html,output">Demo</a>，我们的动画是使一个红色的 <code>div</code> 向右移动。Demo 中是通过每一帧改变其 <code>transform</code> 属性完成的（Canvas 绘制操作也一样）。</p>
<p>然后，我创建了一个会阻塞浏览器的任务：获取 4x10<sup>6</sup> 次 <code>Math.random()</code> 的平均值。点击按钮，这个任务就会被执行，其结果也会打印在屏幕上。</p>
<p><img src="http://gw.alicdn.com/tps/TB13HZILpXXXXacXXXXXXXXXXXX-296-369.png" alt=""></p>
<p>如你所见，如果直接执行这个任务，动画会明显地「卡」一下。而使用 Web Worker 或将任务拆分，则不会卡。</p>
<blockquote>
<p>以上两种优化策略，有一个相同的前提，即任务是异步的。也就是说，当你决定开始执行一项任务的时候，你并不需要立刻（在下一帧）知道结果。比如，即使战略游戏中用户的某个操作触发了寻路算法，你完全可以等待几帧（用户完全感知不到）再开始移动游戏角色。
另外，将任务拆分以优化性能，会带来显著的代码复杂度的增加，以及额外的开销。有时候，我觉得也许可以考虑优先砍一砍需求。</p>
</blockquote>
<h1 id="-">小结</h1>
<p>正文就到这里，最后我们来稍微总结一下，在大部分情况下，需要遵循的「最佳实践」。</p>
<ol>
<li>将渲染阶段的开销转嫁到计算阶段之上。</li>
<li>使用多个分层的 Canvas 绘制复杂场景。</li>
<li>不要频繁设置绘图上下文的 font 属性。</li>
<li>不在动画中使用 putImageData 方法。</li>
<li>通过计算和判断，避免无谓的绘制操作。</li>
<li>将固定的内容预先绘制在离屏 Canvas 上以提高性能。</li>
<li>使用 Worker 和拆分任务的方法避免复杂算法阻塞动画运行。</li>
</ol>
]]></description>
            <link>http://xieguanglei.github.io/post/canvas-best-practice-performance.html</link>
            <guid isPermaLink="false">canvas-best-practice-performance</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Mon, 25 Jan 2016 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>