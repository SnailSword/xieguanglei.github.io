<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[一叶斋]]></title>
        <description><![CDATA[一叶障目 一叶知秋]]></description>
        <link>http://xieguanglei.github.io/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Thu, 08 Mar 2018 05:29:06 GMT</lastBuildDate>
        <atom:link href="http://xieguanglei.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[G3D —— Hybrid 环境下的 WebGL 3D 渲染引擎]]></title>
            <description><![CDATA[<h1 id="g3d-hybrid-webgl-3d-">G3D —— Hybrid 环境下的 WebGL 3D 渲染引擎</h1>
<blockquote>
<p>G3D 是一款开源 3D 渲染引擎，目前由我开发和维护。这篇宣传最初发表于<a href="http://taobaofed.org/blog/2018/03/05/intro-to-g3d/">淘宝前端团队博客</a>。这里是个人博客上保存的一份备份。</p>
</blockquote>
<p>G3D 是一款基于 WebGL 的 JavaScript 3D 渲染引擎，借助 GCanvas，G3D 可以运行在 Weex，ReactNative 等 hybrid 环境下。G3D 由淘宝终端团队推出，并于 2018 年 3 月与 GCanvas 同时宣布正式开源。</p>
<p>那么就会有同学问了，G3D 和 three.js 有什么不同呀？G3D 和 GCanvas 究竟是什么关系啊？这篇文章，就聊一聊 G3D 这个产品的来龙去脉。</p>
<p><a href="https://alibaba.github.io/G3D/">G3D 官网</a>，<a href="https://alibaba.github.io/GCanvas/">GCanvas 官网</a></p>
<h2 id="-g3d">为什么有 G3D</h2>
<p>G3D 的起源要从 GCanvas 说起。</p>
<p>GCanvas 在 Weex 和 ReactNative 环境下提供了浏览器环境中 Canvas 的绘图能力，手机淘宝 App 的 Weex 容器已经内置了 GCanvas。和 Canvas 一样，GCanvas 的绘图能力包括 2d 上下文和 webgl 上下文的绘图能力。2d 上下文相对较为简单，可以直接拿来使用；而 webgl 上下文比较复杂，从 webgl API 到真正的 3d 应用之间往往还需要一层 3d 渲染引擎，社区中的 three.js，babylon.js 等就是这类 3d 渲染引擎中的翘楚。</p>
<p>GCanvas 开发团队曾尝试把 three.js 和 babylon.js 接入到 GCanvas 环境中来，遇到了一些困难：</p>
<ul>
<li>社区中的 webgl 渲染引擎依赖了大量的 DOM API 和原生对象，在 Weex 与 ReactNative 环境中不存在这些 API 与原生对象。开发团队也曾尝试对 Babylon.js 和 three.js 进行改造，但发现成本比较高，而且后续跟进原版项目 bugfix 与功能迭代的难度也比较大。</li>
<li>如 GCanvas 文档所述， GCanvas 目前仅支持 WebGL API 的一个子集。直接引入 Babylon.js 和 three.js，在 GCanvas环境下还暂时无法正常工作。</li>
<li>由于 three.js 和 babylon.js 的体积已经比较巨大，其中很多功能在手机淘宝的业务场景中暂时用不到。因此，即使能够成功改造，巨大的 js 体积也会拖垮手淘中很多页面的性能。</li>
</ul>
<p>所以，GCanvas 开发团队决定从零开始开发一个小型的 WebGL 渲染引擎 G3D，并以此作为 GCanvas 3D 能力的辅助。可以预见，G3D 和 GCanvas WebGL 将会是相辅相成，互相促进，共同发展；并且在较长一段时间内，G3D 将是使用 GCanvas WebGL 能力，除了直接操作原生 WebGL API 之外的唯一选择。</p>
<h2 id="g3d-">G3D 有哪些功能</h2>
<p>G3D 具有 3D 渲染引擎的基本功能：</p>
<ul>
<li>定义场景，定义透视相机。</li>
<li>光照方面，目前支持 1)环境光；2)平行光；3)点光；4)穹顶光。</li>
<li>材质方面，目前支持 1)基于冯氏反射模型的冯式面材质（朗伯面是冯氏面的一种特殊情况）；2) 非光照材质。</li>
<li>几何体方面，目前支持直接创建的几何体包括立方体，球体，圆柱，圆锥，折线；当然更多情况下是可以通过解析模型数据创建几何体。</li>
<li>模型解析方面，目前支持 1) OBJ/MTL 模型；2) STL 模型这两种模型格式。</li>
<li>交互：支持 3D点选/拖拽（由于 GCanvas framebuffer 仍未正常，此功能仅在浏览器中有效）。</li>
<li>动画：支持骨骼动画和蒙皮动画。</li>
</ul>
<p>值得注意的是，由于 G3D 需要运行在 Hybrid 环境下，无法依赖 DOM API，所以与 three.js，babylon.js 等浏览器环境的引擎相比，G3D 无法支持诸如声音播放，文件加载等非渲染核心功能。举例来说，如果使用 three.js 加载模型，只需要调用相关方法传入模型的 url 即可，three.js 会自动加载和解析模型；但在使用 G3D 时，你需要手动获取该文件的内容（Hybrid 与浏览器会不一样），然后将内容字符串传入 G3D.MeshBuilder 的相关方法。</p>
<h2 id="g3d-">G3D 的未来</h2>
<p>目前 G3D 已经在淘宝 3D 定制等业务中有所使用，在未来的半年到一年里，G3D 主要的目的有两个：</p>
<ul>
<li>追赶 Babylon.js 和 three.js 的高阶功能，如阴影、Shader材质、预处理、法线纹理、光线追踪等等，在其过程中推动 GCanvas WebGL 的完善，同时赋能业务和社区。</li>
<li>进一步打通 G3D 与建模-动画工具链的通道，完善模型-材质数据结构，提升渲染效果，达到「（Blender 等工具中）所见即（G3D渲染出）所得」的开发体验，最大程度地降低 3D 项目的开发成本。</li>
</ul>
]]></description>
            <link>http://xieguanglei.github.io/post/about-g3d.html</link>
            <guid isPermaLink="false">about-g3d</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Wed, 07 Mar 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Dalaran —— 开箱即用的 Webpack]]></title>
            <description><![CDATA[<h1 id="dalaran-webpack">Dalaran —— 开箱即用的 Webpack</h1>
<p>不知不觉已经到了 2018 年，Webpack / Babel 早已是前端标配。但是每次新开一个项目，都要重新配置一遍环境，实在是痛苦不堪。然而每个项目的情况，并不存在一个包治百病的 Webpack 配置，而且有时开发环境里还需用到 Webpack 之外的其他工具。所以，我花了一些时间开发了一个开箱即用的 Webpack 任务工厂，既能够减少配置 Webpack 及周边工具的痛苦，又保持了相当的灵活性。我把这个工具命名为 dalaran （达拉然）。</p>
<p>工具地址：<a href="https://github.com/xieguanglei/dalaran">github</a> <a href="https://www.npmjs.com/package/dalaran">dalaran</a></p>
<p><strong>以下是 Dalaran 中文文档：</strong></p>
<p>Dalaran 是一个帮助你简化 Webpack 配置的轻量级工具。与其他重量级开发环境框架相比，dalaran 把「定义自己开发流程」的权力交还给了你自己，你需要使用 <a href="https://gulpjs.com/">Gulp</a> 来管理任务。</p>
<blockquote>
<p>Dalaran（达拉然）的名字来源于网络游戏「魔兽世界」中的魔法城市，达拉然。</p>
</blockquote>
<p>下面是使用文档：</p>
<p>Dalaran 可以帮助你做：</p>
<ul>
<li>对 webpack 配置默认的 loader 和 plugin，对 babel 配置默认的 preset。</li>
<li>根据默认或者自定义的规则找到入口文件和打包目录。</li>
<li>无需配置（或少量配置）即可在 karma 和 chrome 里运行测试用例。</li>
<li>无需配置（或自定义配置）即可使用 eslint 检查代码拼写。</li>
<li>使用 webpack-dev-middleware 和 express 提供开发环境。</li>
<li>在发布模块或部署脚本之前，对代码进行编译或打包。</li>
</ul>
<h2 id="-">使用方法</h2>
<p>基本上，你可以使用 dalaran 来：</p>
<ul>
<li>开发一个前端应用（Application）。</li>
<li>开发一个前端库（Library）。</li>
</ul>
<p>你需要进行的任务包括开发（dev），构建（build）/编译（compile），测试（test）。推荐使用 gulp 来管理这些任务。</p>
<p>你的 gulpfile 大概是这样的：</p>
<pre><code class="lang-javascript">const gulp = requir(&#39;gulp&#39;);
const dalaran = requre(&#39;dalaran&#39;);

const libTasks = dalaran.libraryTasks({...options});

gulp.task(&#39;dev&#39;, libTasks.dev);
gulp.task(&#39;test&#39;, libTasks.test);

gulp.task(&#39;prepare&#39;, function(){
    // 自定义的任务
})
</code></pre>
<h2 id="-library-">开发一个前端库（Library）</h2>
<p>Dalaran 为开发前端库提供了 4 个任务：dev，build，compile 和 test。</p>
<p>调用 <code>tasks.libraryTasks(options)</code> 来创建这些任务。</p>
<h3 id="options">options</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>开发服务器端口</td>
<td>Number</td>
<td>3000</td>
</tr>
<tr>
<td>base</td>
<td>项目的根目录</td>
<td>Sting</td>
<td>process.cwd()</td>
</tr>
<tr>
<td>entry</td>
<td>前端库的入口文件</td>
<td>String</td>
<td>&#39;./src/index.js&#39;</td>
</tr>
<tr>
<td>src</td>
<td>源码目录</td>
<td>String</td>
<td>&#39;./src&#39;</td>
</tr>
<tr>
<td>lib</td>
<td>编译（为 es5 以发布到 npm）后代码存放目录</td>
<td>String</td>
<td>&#39;./lib&#39;</td>
</tr>
<tr>
<td>demo</td>
<td>demo 页目录（用于开发或功能演示）</td>
<td>String</td>
<td>&#39;./demo&#39;</td>
</tr>
<tr>
<td>dist</td>
<td>构建产物存放目录（UMD 类文件）</td>
<td>String</td>
<td>&#39;./dist&#39;</td>
</tr>
<tr>
<td>umdName</td>
<td>UMD 库名</td>
<td>String</td>
<td>&#39;foo&#39;</td>
</tr>
<tr>
<td>devSuffix</td>
<td>开发环境打包后文件的后缀名（除外<code>.js</code>）</td>
<td>String</td>
<td>&#39;bundle&#39;</td>
</tr>
<tr>
<td>buildSuffix</td>
<td>构建时打包后文件的后缀名（除外<code>.js</code>）</td>
<td>String</td>
<td>&#39;min&#39;</td>
</tr>
<tr>
<td>react</td>
<td>是否转译 JSX</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>loaders</td>
<td>额外的自定义 webpack loaders</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>plugins</td>
<td>额外的自定义 webpack plugins</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>babelPolyfill</td>
<td>是否需要引入 babelPolyfill</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>devCors</td>
<td>开发服务器是否开启资源跨域</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>watchTest</td>
<td>测试任务是否为 watch 模式</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>testEntryPattern</td>
<td>测试文件的路径模式</td>
<td>String</td>
<td>&#39;src/<em>*/</em>.spec.js&#39;</td>
</tr>
<tr>
<td>eslint</td>
<td>是否开启 eslint</td>
<td>Boolean</td>
<td>true</td>
</tr>
</tbody>
</table>
<h3 id="-">目录结构</h3>
<p>默认情况下，项目的目录结构大致如下所示：</p>
<pre><code>project
│   README.md
│   package.json
│   gulpfile.js
└───demo
│       foo.html
│       foo.js
│       bar.html
│       bar.js
└───dist
│       foo.min.js
└───lib
│   │   index.js
│   └───foo
│           foo.js
└───src
    │   index.js
    └───foo
            foo.js
            foo.spec.js
</code></pre><h3 id="dev-">dev 任务</h3>
<pre><code>gulp.task(&#39;dev&#39;, libTasks.dev);
</code></pre><p>将需要调试的 demo 页面放置在默认为 &#39;./demo&#39; 的目录下。具有相同名称的 html 和 js 文件即可以构成一个 demo 页面，比如 <code>foo.html</code> 和 <code>foo.js</code> 就组成了名为 <code>foo</code> 的 demo 页面。HTML 文件大致如下所示：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;./foo.bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>你可以任意更改该 html 文件，唯一需要记住的是，页面需要包含如下 script 标签 <code>&lt;script src=&quot;/foo.bundle.js&quot;&gt;&lt;/script&gt;</code>，也就是以 <code>foo.js</code> 为入口打包出的文件。后缀名 <code>bundle</code> 可以在 <code>devSuffix</code> 中修改。</p>
<p><code>foo.js</code> 大致如下所示：</p>
<pre><code>import MyLib from &#39;../src/index&#39;;
// demo code
</code></pre><p>运行 <code>gulp dev</code>，dalaran 会自动打开你的浏览器并打开 <code>http://127.0.0.1:3000</code> （如果你不指定其他端口的话），此时你会看到你的 demo 页面列表。</p>
<p>点击 demo 页面的 <code>link</code> 链接，就可以进入开发调试环境了。</p>
<p>注意，eslint 是默认开启的，dalaran 提供了一份默认的 eslint 配置。如果你在根目录下放置了一个自定义的 .eslintrc，则会覆盖默认的配置。</p>
<h3 id="test-">test 任务</h3>
<p>通过配置 <code>testEntryPattern</code> 参数，dalaran 可以在 Karma 和 Chrome 里运行测试用例。测试文件的示例（比如 <code>foo.spec.js</code>）如下所示：</p>
<pre><code class="lang-javascript">import expect from &#39;expect&#39;;
import MyLib from &#39;../src/index&#39;;

describe(&#39;mylib&#39;, function () {

    it(&#39;mylib should be ok&#39;, function(){
        expect(!!MyLib).toBeTruthy();
    });

});
</code></pre>
<p>运行 <code>gulp test</code> 测试结果会输出到命令行。</p>
<h3 id="build-">build 任务</h3>
<pre><code class="lang-javascript">gulp.task(&#39;build&#39;, libTasks.build);
</code></pre>
<p>运行 <code>gulp build</code> 将会以模块的入口文件（默认为&#39;./src/index.js&#39;）打包出一个 UMD 风格的 js 文件并放置在 <code>dist</code> 目录下。你需要提供一个 <code>umdName</code> 选项，该文件将被命名为 <code>${umdName.toLowercase()}.${buildSuffix}.js</code>。如果你通过 script 标签加载并运行该 js 文件，就可以使用 <code>window.${umdName}</code> 变量获取到该模块。</p>
<h3 id="compile-">compile 任务</h3>
<pre><code class="lang-javascript">gulp.task(&#39;build&#39;, libTasks.build);
</code></pre>
<p>如果你的源码仅包含 js 文件（也就是说，你不会通过一些额外的 loader 来加载 <code>.less</code>, <code>.txt</code>, <code>.jpg</code> 等文件），你就可以将 es6 / jsx 代码编译为 es5，然后发布到 npm 上供他人进一步使用。这样做的好处是，如果你的库依赖了其他 npm 库，就不会将其打包进去（UMD 则会）。编译后的文件，被放置在 <code>lib</code> 目录下（你可以通过 <code>lib</code> 选项来修改）。</p>
<p>运行 <code>gulp compile</code>, 编译任务会很快完成。</p>
<h2 id="-application-">开发一个前端应用（Application）</h2>
<p>Dalaran 为开发前端应用提供了 3 个任务：dev，build 和 test。</p>
<p>你需要调用 <code>tasks.applicationTasks(options)</code> 来创建这些任务。</p>
<h3 id="options">options</h3>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>type</th>
<th>default</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>开发服务器端口</td>
<td>Number</td>
<td>3000</td>
</tr>
<tr>
<td>base</td>
<td>项目的根目录</td>
<td>Sting</td>
<td>process.cwd()</td>
</tr>
<tr>
<td>src</td>
<td>源码目录</td>
<td>String</td>
<td>&#39;./src&#39;</td>
</tr>
<tr>
<td>demo</td>
<td>应用的页面目录</td>
<td>String</td>
<td>&#39;./demo&#39;</td>
</tr>
<tr>
<td>dist</td>
<td>构建产物存放目录</td>
<td>String</td>
<td>&#39;./dist&#39;</td>
</tr>
<tr>
<td>devSuffix</td>
<td>开发环境打包后文件的后缀名（除外<code>.js</code>）</td>
<td>String</td>
<td>&#39;bundle&#39;</td>
</tr>
<tr>
<td>buildSuffix</td>
<td>构建时打包后文件的后缀名（除外<code>.js</code>）</td>
<td>String</td>
<td>&#39;bundle&#39;</td>
</tr>
<tr>
<td>react</td>
<td>是否转译 JSX</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>loaders</td>
<td>额外的自定义 webpack loaders</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>plugins</td>
<td>额外的自定义 webpack plugins</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>babelPolyfill</td>
<td>是否需要引入 babelPolyfill</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>devCors</td>
<td>开发服务器是否开启资源跨域</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>watchTest</td>
<td>测试任务是否为 watch 模式</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>testEntryPattern</td>
<td>测试文件的路径模式</td>
<td>String</td>
<td>&#39;src/<em>*/</em>.spec.js&#39;</td>
</tr>
<tr>
<td>commonsChunk</td>
<td>是否开启 commonsChunk Plugin</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>publicPath</td>
<td>应用部署路径的 path</td>
<td>String</td>
<td>&#39;./&#39;</td>
</tr>
<tr>
<td>eslint</td>
<td>是否开启 eslint</td>
<td>Boolean</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>与开发前端库时的选项相比，有几点区别：</p>
<ol>
<li>不需要指定 entry 选项，入口会从 demo 目录内分析出来。</li>
<li>不需要提供 umdName 选项。</li>
<li>不需要提供 lib 目录。</li>
<li><code>buildSuffix</code> 的默认值是 <code>bundle</code> 而不是 <code>min</code>。</li>
<li>可以使用 <code>commonsChunk</code> 选项开启该插件。</li>
</ol>
<h3 id="-">目录结构</h3>
<p>项目的根目录的结构大致如下所示：</p>
<pre><code class="lang-bash">project
│   README.md
│   package.json
│   gulpfile.js
└───demo
│       foo.html
│       foo.js
│       bar.html
│       bar.js
└───dist
│       foo.html
│       foo.bundle.js
│       bar.html
│       bar.bundle.js
└───src
    │   index.js
    └───foo
            foo.js
            foo.spec.js
</code></pre>
<p>Compared with library tasks, there are 2 main differences. </p>
<p>与开发前端库相比，主要有两点区别：</p>
<ol>
<li>不再需要 lib 目录。</li>
<li>dist 目录中的内容，像是 demo 目录的映射一样。（开发前端库时，此目录下只有一个 UMD 文件）。</li>
<li>如果你开启了 commonsChunk 插件，则 html 中也需要包含该插件提取出的公共内容。就像这样：</li>
</ol>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;./commons.bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./foo.bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="dev-">dev 任务</h3>
<p>Dev 任务与开发前端库时完全一致。</p>
<h3 id="test-">test 任务</h3>
<p>Test 任务与开发前端库时完全一致。</p>
<h3 id="build-">build 任务</h3>
<p>与开发前端库时相比，build 任务有些不同。此时，build 任务将会对 demo 目录下的每一个页面的入口 js 文件进行打包，同时也会将 html 文件复制到 dist 目录下。你可以将 dist 目录中打包后的 js 部署到静态资源服务器（比如使用内容分发网络）上，然后在自己的页面里加载这个 js 文件。当然，你也可以将整个 dist 目录部署在静态文件服务器上（比如使用 gh-pages），这也行得通。</p>
<blockquote>
<p>注意，开发前端应用时，是没有 compile 任务的。</p>
</blockquote>
<h2 id="-">如果你仍然有疑问</h2>
<p>你可以查看本仓库 <code>packages</code> 目录中的内容，该目录下有 4 个子目录，每一个都表示一个项目。你可以试着把它们运行起来，以了解 dalaran 是如何工作的。</p>
]]></description>
            <link>http://xieguanglei.github.io/post/dalaran-the-webpack-tool.html</link>
            <guid isPermaLink="false">dalaran-the-webpack-tool</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Sat, 03 Mar 2018 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[编写「可读」代码的实践]]></title>
            <description><![CDATA[<h1 id="-">编写「可读」代码的实践</h1>
<p>编写<strong>可读</strong>的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是<strong>能够被阅读</strong>，其次才是<strong>能够被正确执行</strong>。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p>
<p>在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。</p>
<blockquote>
<p>JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p>
<p>这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。</p>
</blockquote>
<h2 id="-">变量命名</h2>
<p>变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p>
<p>命名必须传递足够的信息，形如 <code>getData</code> 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 <code>fetchUserInfoAsync</code> 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 <code>Async</code> 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p>
<h3 id="-">命名的基础</h3>
<p>通常，我们使用名词来命名对象，使用动词来命名函数。比如：</p>
<pre><code>monkey.eat(banana)  // the money eats a banana
const apple = pick(tree)  // pick an apple from the tree
</code></pre><p>这两句代码与自然语言（右侧的注释）很接近，即使完全不了解编程的人也能看懂大概。</p>
<p>有时候，我们需要表示某种集合概念，比如数组或哈希对象。这时可以通过名词的复数形式来表示，比如用 <code>bananas</code> 表示一个数组，这个数组的每一项都是一个 <code>banana</code>。如果需要特别强调这种集合的形式，也可以加上 <code>List</code> 或 <code>Map</code> 后缀来显式表示出来，比如用 <code>bananaList</code> 表示数组。</p>
<blockquote>
<p>有些单词的复数形式和单数形式相同，有些不可数的单词没有复数形式（比如 data，information），这时我也会使用 <code>List</code> 等后缀来表示集合概念。</p>
</blockquote>
<h3 id="-">命名的上下文</h3>
<p>变量都是处在<strong>上下文</strong>（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。举个例子，假设我们的程序需要管理一个动物园，程序的代码里有一个名为 <code>feedAnimals</code> 的函数来喂食动物园中的所有动物：</p>
<pre><code>function feedAnimals(food, animals){
  // ...
  // 上下文中有 bananas, peaches, monkey 变量
  const banana = bananas.pop();
  if(banana){
    monkey.eat(banana);
  } else {
    const peach = peaches.pop();
    monkey.eat(peach);
  }
  // ...
}
</code></pre><p>负责喂食动物的函数 <code>feedAnimals</code> 函数的主要逻辑就是：用各种食物把动物园里的各种动物喂饱。也许，每种动物能接受的食物种类不同，也许，我们需要根据各种食物的库存来决定每种动物最终分到的食物，总之在这个上下文中，我们需要关心食物的种类，所以传给 <code>money.eat</code> 方法的实参对象命名为 <code>banana</code> 或者 <code>peach</code>，代码很清楚地表达出了它的关键逻辑：「猴子要么吃香蕉，要么吃桃子（如果没有香蕉了）」。我们肯定不会这样写：</p>
<pre><code>// 我们不会这样写
const food = bananas.pop();
if(food){
  monkey.eat(food);
} else {
  const food = peaches.pop();
  monkey.eat(food);
}
</code></pre><p><code>Monkey#eat</code> 方法内部就不一样了，这个方法很可能是下面这样的（假设 <code>eat</code> 是 <code>Monkey</code> 的基类 <code>Animal</code> 的方法）：</p>
<pre><code>class Animal{
  // ...
  eat(food){
    this.hunger -= food.energy;
  }
  // ...
}

class Monkey extends Animal{ 
  // ... 
}
</code></pre><p>如代码所示，「吃」这个方法的核心逻辑就是根据食物的能量来减少动物（猴子）自身的饥饿度，至于究竟是吃了桃子还是香蕉，我们不关心，所以在这个方法的上下文中，我们直接将表示食物的函数形参命名为 <code>food</code>。</p>
<p>想象一下，假设我们正在编写某个函数，即将写一段公用逻辑，我们会选择去写一个新的功能函数来执行这段公用逻辑。在编写这个新的功能函数过程中，往往会受到之前那个函数的影响，变量的命名也是按照其在之前那个函数中的意义来的。虽然写的时候不感觉有什么阻碍，但是读者阅读的单元是函数（他并不了解之前哪个函数），会被深深地困扰。</p>
<h3 id="-">严格遵循一种命名规范的收益</h3>
<p>如果你能够时刻按照某种严格的规则来命名变量和函数，还能带来一个潜在的好处，那就是你再也不用<strong>记住</strong>哪些之前命名过（甚至其他人命名过）的变量或函数了。特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。比如，「获取用户信息」这个概念，就叫作 <code>fetchUserInfomation</code>，不管是在早晨还是傍晚，不管你是在公司还是家中，你都会将它命名为 <code>fetchUserInfomation</code> 而不是 <code>getUserData</code>。那么当你再次需要使用这个变量时，你根本不用翻阅之前的代码或依赖 IDE 的代码提示功能，你只需要再<strong>命名</strong>一下「获取用户信息」这个概念，就可以得到 <code>fetchUserInfomation</code> 了，是不是很酷？</p>
<h2 id="-">分支结构</h2>
<p>分支是代码里最常见的结构，一段结构清晰的代码单元应当是像二叉树一样，呈现下面的结构。</p>
<pre><code>if (condition1) {
  if (condition2) {
    ...
  } else {
    ...
  }
} else {
  if (condition3) {
    ...
  } else {
    ...
  }
}
</code></pre><p>这种优美的结构能够帮助我们在大脑中迅速绘制一张图，便于我们在脑海中模拟代码的执行。但是，我们大多数人都不会遵循上面这样的结构来写分支代码。以下是一些常见的，在我看来可读性比较差的分支语句的写法：</p>
<h3 id="-return">不好的做法：在分支中 return</h3>
<pre><code>function foo(){
  if(condition){
    // 分支1的逻辑
    return;
  }
  // 分支2的逻辑
}
</code></pre><p>这种分支代码很常见，而且往往分支2的逻辑是先写的，也是函数的主要逻辑，分支1是后来对函数进行修补的过程中产生的。这种分支代码有一个很致命的问题，那就是，如果读者没有注意到分支1中的 <code>return</code>（我敢保证，在使用 IDE 把代码折叠起来后，没人能第一时间注意到这个 <code>return</code>），就不会意识到后面一段代码（分支 2）是有可能不会执行的。我的建议是，把分支2放到一个 <code>else</code> 语句块中，代码就会清晰可读很多：</p>
<pre><code>function foo(){
  if(condition){
    // 分支 1 的逻辑
  } else {
    // 分支 2 的逻辑
  }
}
</code></pre><blockquote>
<p>如果某个分支是空的，我也倾向于留下一个空行，这个空行明确地告诉代码的读者，如果走到这个 <code>else</code>，我什么都不会做。如果你不告诉读者，读者就会产生怀疑，并尝试自己去弄明白。</p>
</blockquote>
<h3 id="-">不好的做法：多个条件复合</h3>
<pre><code>if (condition1 &amp;&amp; condition2 &amp;&amp; condition3) {
  // 分支1：做一些事情
} else {
  // 分支2：其他的事情
}
</code></pre><p>这种代码也很常见：在若干条件同时满足（或有任一满足）的时候做一些主要的事情（分支1，也就是函数的主逻辑），否则就做一些次要的事情（分支2，比如抛异常，输出日志等）。虽然写代码的人知道什么是主要的事情，什么是次要的事情，但是代码的读者并不知道。读者遇到这种代码，就会产生困惑：分支2到底对应了什么条件？</p>
<p>在上面这段代码中，三种条件只要任意一个不成立就会执行到分支2，但这其实<strong>本质</strong>上是多个分支：1)条件1不满足，2)条件1满足而条件2不满足，3)条件1和2都满足而条件3不满足。如果我们笼统地使用同一段代码来处理多个分支，那么就会增加阅读者阅读分支2时的负担（需要考虑多个情况）。更可怕的是，如果后面需要增加一些额外的逻辑（比如，在条件1成立且条件2不成立的时候多输出一条日志），整个 <code>if-else</code> 都可能需要重构。</p>
<p>对这种场景，我通常这样写：</p>
<pre><code>if(condition1){
  if(condition2){
    // 分支1：做一些事情
  }else{
    // 分支2：其他的事情
  }
}else{
  // 分支3：其他的事情
}
</code></pre><p>即使分支2和分支3是完全一样的，我也认为有必要将其分开。虽然多了几行代码，收益却是很客观的。</p>
<blockquote>
<p>万事非绝对。对于一种情况，我不反对将多个条件复合起来，那就是当被复合的多个条件联系十分紧密的时候，比如 <code>if(foo &amp;&amp; foo.bar)</code>。</p>
</blockquote>
<h3 id="-">不好的做法：使用分支改变环境</h3>
<pre><code>let foo = someValue;
if(condition){
  foo = doSomethingTofoo(foo);
}
// 继续使用 foo 做一些事情
</code></pre><p>这种风格的代码很容易出现在那些屡经修补的代码文件中，很可能一开始是没有这个 <code>if</code> 代码块的，后来发现了一个 bug，于是加上了这个 <code>if</code> 代码块，在某些条件下对 <code>foo</code> 做一些特殊的处理。如果你希望项目在迭代过程中，风险越积越高，那么这个习惯绝对算得上「最佳实践」了。</p>
<p>事实上，这样的「补丁」积累起来，很快就会摧毁代码的可读性和可维护性。怎么说呢？当我们在写下上面这段代码中的 <code>if</code> 分支以试图修复 bug 的时候，我们内心存在这样一个假设：我们是<strong>知道</strong>程序在执行到这一行时，<code>foo</code> 什么样子的；但事实是，我们根本<strong>不知道</strong>，因为在这一行之前，<code>foo</code> 很可能已经被另一个人所写的尝试修复另一个 bug 的另一个 if 分支所篡改了。所以，当代码出现问题的时候，我们应当完整地审视一段独立的功能代码（通常是一个函数），并且多花一点时间来修复他，比如：</p>
<pre><code>const foo = condition ? doSomethingToFoo(someValue) : someValue;
</code></pre><p>我们看到，很多风险都是在项目快速迭代的过程中积累下来的。为了「快速」迭代，在添加功能代码的时候，我们有时候连函数这个最小单元的都不去了解，仅仅着眼于自己插入的那几行，希望在那几行中解决/hack掉所有问题，这是十分不可取的。</p>
<p>我认为，项目的迭代再快，其代码质量和可读性都应当有一个底线。这个底线是，当我们在修改代码的时候，应当<strong>完整了解当前修改的这个函数的逻辑</strong>，然后<strong>修改这个函数</strong>，以达到添加功能的目的。注意，这里的「修改一个函数」和「在函数某个位置添加几行代码」是不同的，在「修改一个函数」的时候，为了保证函数功能独立，逻辑清晰，不应该畏惧在这个函数的任意位置增删代码。</p>
<h2 id="-">函数</h2>
<h3 id="-">函数只做一件事情</h3>
<p>有时，我们会自作聪明地写出一些很「通用」的函数。比如，我们有可能写出下面这样一个获取用户信息的函数 <code>fetchUserInfo</code>：其逻辑是：</p>
<p>1) 当传入的参数是用户ID（字符串）时，返回单个用户数据；
2) 而传入的参数是用户ID的列表（数组）时，返回一个数组，其中的每一项是一个用户的数据。</p>
<pre><code>async function fetchUserInfo(id){
  const isSingle = typeof idList === &#39;string&#39;;
  const idList = isSingle ? [id] : id;
  const result = await request.post(&#39;/api/userInfo&#39;, {idList});
  return isSingle ? result[0] : result;
}

// 可以这样调用
const userList = await fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;]);
// 也可以这样调用
const user = await fetchUserInfo(&#39;1017&#39;);
</code></pre><p>这个函数能够做两件事：1)获取多个用户的数据列表；2)获取单个用户的数据。在项目的其他地方调用 <code>fetchUserInfo</code> 函数时，也许我们确实能感到「方便」了一些。但是，代码的读者一定不会有相同的体会，当读者在某处读到 <code>fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;])</code> 这句调用的代码时，他就会立刻对 <code>fetchUserInfo</code> 产生「第一印象」：这个函数需要传入用户ID数组；当他读到另外一种调用形式时，他一定会怀疑自己之前是不是眼睛花了。读者并不了解背后的「潜规则」，除非规则是预先设计好并且及时地更新到文档中。总之，我们绝不该一时兴起就写出上面这种函数。</p>
<p>遵循<strong>一个函数只做一件事</strong>的原则，我们可以将上述功能拆成两个函数<code>fetchMultipleUser</code> 和 <code>fetchSingleUser</code> 来实现。在需要获取用户数据时，只需要选择调用其中的一个函数。</p>
<pre><code>async function fetchMultipleUser(idList){
  return await request.post(&#39;/api/users/&#39;, {idList});
}

async function fetchSingleUser(id){
  return await fetchMultipleUser([id])[0];
}
</code></pre><p>上述改良不仅改善了代码的可读性，也改善了可维护性。举个例子，假设随着项目的迭代，获取单一用户信息的需求不再存在了。</p>
<ul>
<li>如果是改良前，我们会删掉那些「传入单个用户ID来调用 <code>fetchUserInfo</code>」的代码，同时保留剩下的那些「传入多个用户ID调用 <code>fetchUserInfo</code>」的代码， 但是 <code>fetchUserInfo</code> 函数几乎一定不会被更改。这样，函数内部 <code>isSingle</code> 为 <code>true</code> 的分支，就留在了代码中，成了永远都不会执行的「脏代码」，谁愿意看到自己的项目中充斥着永远不会执行的代码呢？</li>
<li>对于改良后的代码，我们（也许借助IDE）能够轻松检测到 <code>fetchSingleUser</code> 已经不会被调用了，然后放心大胆地直接删掉这个函数。</li>
</ul>
<p>那么，如何界定某个函数做的是不是<strong>一件事情</strong>？我的经验是这样：如果一个函数的参数仅仅包含<strong>输入数据（交给函数处理的数据）</strong>，而没有混杂或暗含有<strong>指令</strong>（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是<strong>一件事情</strong>。比如说，改良前的 <code>fetchUserInfo</code> 函数的参数是「多个用户的ID数组<strong>或</strong>单个用户的ID」，这个「或」字其实就暗含了某种指令。</p>
<h3 id="-">函数应适当地处理异常</h3>
<p>有时候，我们会陷入一种很不好的习惯中，那就是，总是去尝试写出永远不会报错的函数。我们会给参数配上默认值，在很多地方使用 <code>||</code> 或者 <code>&amp;&amp;</code> 来避免代码运行出错，仿佛如果你的函数报错会成为某种耻辱似的。而且，当我们尝试去修复一个运行时报错的函数时，我们往往倾向于在报错的那一行添加一些兼容逻辑来避免报错。</p>
<p>举个例子，假设我们需要编写一个获取用户详情的函数，它要返回一个完整的用户信息对象：不仅包含ID，名字等基本信息，也包含诸如「收藏的书籍」等通过额外接口返回的信息。这些额外的接口也许不太稳定：</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUser(id);
  user.favoriteBooks = (await fetchUserFavorits(id)).books;
  // 上面这一行报错了：Can not read property &#39;books&#39; of undefined.
  // ...
}
</code></pre><p>假设 <code>fetchUserFavorites</code> 会时不时地返回 <code>undefined</code>，那么读取其 <code>books</code> 属性自然就会报错。为了修复该问题，我们很可能会这样做：</p>
<pre><code>const favorites = await fetchUserFavorits(id);
user.favoriteBooks = favorites &amp;&amp; favorites.books;
// 这下不会报错了
</code></pre><p>这样做看似解决了问题：的确，<code>getUserDetail</code> 不会再报错了，但同时埋下了更深的隐患。</p>
<p>当 <code>fetchUserFavorites</code> 返回 <code>undefined</code> 时，程序已经处于一种异常状态了，我们没有任何理由放任程序继续运行下去。试想，如果后面的某个时刻（比如用户点击「我收藏的书」选项卡），程序试图遍历 <code>user.favoriteBooks</code> 属性（它被赋值成了<code>undefined</code>），那时也会报错，而且那时排查起来会更加困难。</p>
<p>如何处理上述的情况呢？我认为，如果被我们依赖的 <code>fetchUserFavorits</code> 属于当前的项目，那么 <code>getUserDetail</code> 对此报错真的没什么责任，因为 <code>fetchUserFavorits</code> 就不应该返回 <code>undefined</code>，我们应该去修复 <code>fetchUserFavorits</code>，任务失败时显式地告知出来，或者直接抛出异常。同时，<code>getUserDetail</code> 稍作修改：</p>
<pre><code>// 情况1：显式告知，此时应认为获取不到收藏数据不算致命的错误
const result = await fetchUserFavorits(id);
if(result.success){
  user.favoriteBooks = result.data.books;
} else {
  user.favoriteBooks = []
}

// 情况2：直接抛出异常
user.favoriteBooks = (await fetchUserFavorits(id)).books;
// 这时 `getUserDetail` 不需要改动，任由异常沿着调用栈向上冒泡
</code></pre><p>那么如果 <code>fetchUserFavorits</code> 不在当前项目中，而是依赖的外部模块呢？我认为，这时你就该为选择了这样一个不可靠的模块负责，在 <code>getUserDetail</code> 中增加一些「擦屁股」代码，来避免你的项目的<strong>其他部分</strong>受到侵害。</p>
<pre><code>const favorites = await fetchUserFavorits(id);
if(favorites){
  user.favoriteBooks = favorites.books;
} else {
  throw new Error(&#39;获取用户收藏失败&#39;);
}
</code></pre><h3 id="-">控制函数的副作用</h3>
<p>无副作用的函数，是<strong>不依赖上下文</strong>，也<strong>不改变上下文</strong>的函数。长久依赖，我们已经习惯了去写「有副作用的函数」，毕竟 JavaScript 需要通过副作用去操作环境的 API 完成任务。这就导致了，很多原本可以用纯粹的、无副作用的函数完成任务的场合，我们也会不自觉地采取有副作用的方式。</p>
<p>虽然看上去有点可笑，但我们有时候就是会写出下面这样的代码！</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUserInfo(id);
  await addFavoritesToUser(user);
  ...
}
async function addFavoritesToUser(user){
  const result = await fetchUserFavorits(user.id);
  user.favoriteBooks = result.books;
  user.favoriteSongs = result.songs;
  user.isMusicFan = result.songs.length &gt; 100;
}
</code></pre><p>上面，<code>addFavoritesToUser</code> 函数就是一个「有副作用」的函数，它改变了 <code>users</code>，给它新增了几个个字段。问题在于，仅仅阅读 <code>getUserData</code> 函数的代码完全无法知道，user 会发生怎样的改变。</p>
<p>一个无副作用的函数应该是这样的：</p>
<pre><code>async function getUserDetail(id){
  const user = await fetchSingleUserInfo(id);
  const {books, songs, isMusicFan} = await getUserFavorites(id);
  return Object.assign(user, {books, songs, isMusicFan})
}
async function getUserFavorites(id){
  const {books, songs} = await fetchUserFavorits(user.id);
  return {
    books, songs, isMusicFan: result.songs.length &gt; 100
  }
}
</code></pre><p>难道这不是理所当然的形式吗？</p>
<h3 id="-">非侵入性地改造函数</h3>
<p>函数是一段独立和内聚的逻辑。在产品迭代的过程中，我们有时候不得不去修改函数的逻辑，为其添加一些新特性。之前我们也说过，一个函数只应做一件事，如果我们需要添加的新特性，与原先函数中的逻辑没有什么联系，那么决定是否通过<strong>改造这个函数</strong>来添加新功能，应当格外谨慎。</p>
<p>仍然用「向服务器查询用户数据」为例，假设我们有如下这样一个函数（为了让它看上去复杂一些，假设我们使用了一个更基本的 <code>request</code> 库）：</p>
<pre><code>const fetchUserInfo = (userId, callback) =&gt; {
  const param = {
    url: &#39;/api/user&#39;,
    method: &#39;post&#39;,
    payload: {id: userId}
  };
  request(param, callback);
}
</code></pre><p>现在有了一个新需求：为 <code>fetchUserInfo</code> 函数增加一道本地缓存，如果第二次请求同一个 userId 的用户信息，就不再重新向服务器发起请求，而直接以第一次请求得到的数据返回。</p>
<p>按照如下快捷简单的解决方案，改造这个函数只需要五分钟时间：</p>
<pre><code>const userInfoMap = {};
const fetchUserInfo = (userId, callback) =&gt; {
  if(userInfoMap[userId]){            // 新增代码
    callback(userInfoMap[userId]);    // 新增代码
  }else{                              // 新增代码
    const param = {
      // ... 参数
    };
    request(param, (result)=&gt;{
      userInfoMap[userId] = result;   // 新增代码
      callback(result);
    });
  }
}
</code></pre><p>不知你有没有发现，经此改造，这个函数的可读性已经明显降低了。没有缓存机制前，函数很清晰，一眼就能明白，加上新增的几行代码，已经不能一眼就看明白了。</p>
<p>实际上，「缓存」和「获取用户数据」完全是独立的两件事。我提出的方案是，编写一个通用的缓存包装函数（类似装饰器）<code>memorizeThunk</code>，对 <code>fetchUserInfo</code> 进行包装，产出一个新的具有缓存功能的 <code>fetchUserInfoCache</code>，在不破坏原有函数可读性的基础上，提供缓存功能。</p>
<pre><code>const memorizeThunk = (func, reducer) =&gt; {
  const cache = {};
  return (...args, callback) =&gt; {
    const key = reducer(...args);
    if(cache[key]){
      callback(...cache[key]);
    }else{
      func(...args, (...result)=&gt;{
        cache[key] = result;
        callback(...result);
      })
    }
  }
}
const fetchUserInfo = (userInfo, callback) =&gt; {
  // 原来的逻辑
}
const fetchUserInfoCache = memorize(fetchUserInfo, (userId)=&gt;userId);
</code></pre><p>也许实现这个方案需要十五分钟，但是试想一下，如果将来的某个时候，我们又不需要缓存功能了（或者需要提供一个开关来打开/关闭缓存功能），修改代码的负担是怎样的？第一种简单方案，我们需要精准（提心吊胆地）地删掉新增的若干行代码，而我提出的这种方案，是以函数为单位增删的，负担要轻很多，不是吗？</p>
<h2 id="-">类的结构</h2>
<h3 id="-">避免滥用成员函数</h3>
<p>JavaScript 中的类，是 ES6 才有的概念，此前是通过函数和原型链来模拟的。在编写类的时候，我们常常忍不住地写很多没必要的成员函数：当类的某个成员函数的内部逻辑有点复杂了，行数有点多了之后，我们往往会将其中一部分「独立」逻辑拆分出来，实现为类的另一个成员函数。比如，假设我们编写某个 React 组件来显示用户列表，用户列表的形式是<strong>每两个用户为一行</strong>。</p>
<pre><code>class UserList extends React.Component{
  // ...
  chunk = (users) =&gt; {
    // 将 [&#39;张三&#39;, &#39;李四&#39;, &#39;王二&#39;, &#39;麻子&#39;] 转化为 [[&#39;张三&#39;, &#39;李四&#39;], [&#39;王二&#39;, &#39;麻子&#39;]]
  }
  render(){
    const chunks = this.chunk(this.props.users);
    // 每两个用户为一行
    return (
      &lt;div&gt;
        {chunks.map(users=&gt;
          &lt;row&gt;
            {users.map(user =&gt; 
              &lt;col&gt;&lt;UserItem user={user}&gt;&lt;/col&gt;
            )}
          &lt;/row&gt;
        )}
      &lt;/div&gt;
    )
  }
}
</code></pre><p>如上述代码所示，<code>UserList</code> 组件按照「两个一行」的方式来显示用户列表，所以需要先将用户列表进行组合。进行组合的工作这件事情看上去是比较独立的，所以我们往往会将 <code>chunk</code> 实现成 <code>UserList</code> 的一个成员函数，在 render 中调用它。</p>
<p>我认为这样做并不可取，因为 chunk 只会被 render 所调用，仅仅服务于 render。阅读这个类源码的时候，读者其实只需要在 render 中去了解 chunk 函数就够了。然而 chunk 以成员函数的形式出现，扩大了它的可用范围，提前把自己曝光给了读者，反而会造成干扰。读者阅读源码，首先就是将代码折叠起来，然后他看到的是这样的景象：</p>
<pre><code>class UserList extends React.Component{
  componentDidMount(){...}
  componentWillUnmount(){...}
  chunk(){...}    // 读者的内心独白：这是什么鬼？
  render(){...}
}
</code></pre><p>熟悉 React 的同学对组件中出现一个不熟悉的方法多半会感到困惑。不管怎么说，读者肯定会首先去浏览一遍这些成员函数，但是阅读 <code>chunk</code> 函数带给读者的信息基本是零，反而还会干扰读者的思路，因为读者现在还不知道用户列表需要以「每两个一行」的方式呈现。所以我认为，<code>chunk</code> 函数绝对应该定义在 <code>render</code> 中，如下所示：</p>
<pre><code>render(){
  const chunk = (users) =&gt; ...
  const chunks = this.chunk(this.props.users);
  return (
    &lt;div&gt;
  ...
}
</code></pre><p>这样虽然函数的行数可能会比较多，但将代码折叠起来后，函数的逻辑则会非常清楚。而且，<code>chunk</code> 函数曝光在读者眼中的时机是非常正确的，那就是，在它即将被调用的地方。实际上，在「计算函数的代码行数」这个问题上，我会把内部定义的函数视为一行，因为函数对读者可以是黑盒，它的负担只有一行。</p>
<h2 id="-">总结</h2>
<p>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复<strong>打磨</strong>自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p>
]]></description>
            <link>http://xieguanglei.github.io/post/write-readable-code-practice.html</link>
            <guid isPermaLink="false">write-readable-code-practice</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Tue, 03 Jan 2017 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：key 属性的原理和用法]]></title>
            <description><![CDATA[<h1 id="react-key-">React 实践心得：key 属性的原理和用法</h1>
<p>我们知道，React 元素可以具有一个特殊的属性 key，这个属性不是给用户自己用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p>
<p>如果你有下面这样的代码：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 没有提供 key
  &lt;/div&gt;
);
</code></pre>
<p>React 会在控制台打印出报警信息：</p>
<blockquote>
<p>Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of <code>App</code>. See <a href="https://fb.me/react-warning-keys">https://fb.me/react-warning-keys</a> for more information.</p>
</blockquote>
<p>你必须为数组中的元素提供唯一的 <code>key</code> 属性，就像下面这样：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div key={u.id}&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 提供了 key
  &lt;/div&gt;
);
</code></pre>
<p>为什么呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如 UserList 组件的 users 属性改变了，就得重新渲染 UserList 组件，包括外部的 <code>&lt;div&gt;</code>（容器），内部的一个 <code>&lt;h3&gt;</code> 和若干个 <code>&lt;div&gt;</code>（每一个描述一个用户）。</p>
<p>对后一种 <code>&lt;div&gt;</code>（表示用户的），由于其处在一个长度不确定的数组中，React 需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。比如以下几种情况：</p>
<ul>
<li><code>[{name: &#39;张三&#39;, age: 20}]</code> =&gt; <code>[{name: &#39;张三&#39;, age: 21}]</code>：这种情况明显只需要更新元素，没有必要重新创建元素。因为人还是那个人，除了 age，其他信息没有变，显示用户姓名的那个（更小的）元素，是不需要更新（被 ReactDOM 操作到）的。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> 这种情况，显然需要添加一个新元素来表示李四，这个新元素对应的 DOM 元素会被插入到页面中。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}]</code>：这种情况就有点复杂了，似乎两种方案都可以。可以把表示张三的元素删掉，为李四新建一个，当然是非常合理的选择。但是直接把张三的元素换成李四，似乎也无不可。</li>
</ul>
<p>实际上，如果真的认为上述第3种的后一种方案也无不可，那可是大错特错了。为什么呢：</p>
<ul>
<li>考虑这种情况：<code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}, {name: &#39;张三&#39;}]</code>，难道也需要把张三的元素更新成李四的，李四的元素更新成张三的吗？</li>
</ul>
<p>那么，为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>
<p>那么，为什么只有数组中的元素需要有唯一的 key，而其他的元素（比如上面的<code>&lt;h3&gt;用户列表&lt;/h3&gt;</code>）则不需要呢？答案是：React 有能力辨别出，更新前后元素的对应关系。这一点，也许直接看 JSX 不够明显，看 Babel 转换后的 React.createElement 则清晰很多：</p>
<pre><code class="lang-jsx">// 转换前
const element = (
  &lt;div&gt;
    &lt;h3&gt;example&lt;/h3&gt;
    {[&lt;p key={1}&gt;hello&lt;/p&gt;, &lt;p key={2}&gt;world&lt;/p&gt;]}
  &lt;/div&gt;
);

// 转换后
&quot;use strict&quot;;

var element = React.createElement(
  &quot;div&quot;,
  null,
  React.createElement(&quot;h3&quot;,null,&quot;example&quot;),
  [
    React.createElement(&quot;p&quot;,{ key: 1 },&quot;hello&quot;), 
    React.createElement(&quot;p&quot;,{ key: 2 },&quot;world&quot;)
  ]
);
</code></pre>
<p>不管 props 如何变化，数组外的每个元素始终出现在 React.createElement() 参数列表中的固定位置，这个位置就是天然的 key。</p>
<blockquote>
<p>题外话</p>
<p>初学 React 时还容易产生另一个困惑，那就是为什么 JSX 不支持 if 表达式来有选择地输出（不能这样：<code>{if(yes){ &lt;div {...props}/&gt; }}</code>），而必须采用三元运算符来完成这项工作（必须这样：<code>{yes ? &lt;div {...props}/&gt;} : null</code>）。那是因为，React 需要一个 null 去占住那个元素本来的位置。</p>
</blockquote>
<p>曾经，我天真的以为 <code>key</code> 这个元素只应在数组中使用。直到我在一个复杂的项目中写出了及其恶心的 <code>componentWillReceiveProps</code>方法。我尝试寻找销毁和重建组件，触发 <code>componentDidMount</code> 方法，重置 <code>state</code>，然后才突然发现 <code>key</code> 这个属性已经在那里了。</p>
<p>举个例子，我们有一个展示用户信息的 <code>UserDashboard</code> 组件。传给组件的 <code>props</code> 只有用户的 基本信息（ID，姓名等），而有关用户的详细信息（比如当前是否在线等）是需要请求过来的。组件内的一些操作（比如尝试与该用户聊天）也会使用请求，组件本身也有各种状态（比如是否显示聊天框）。</p>
<p>整个界面上最多只有一个 <code>UserDashboard</code>，但某些操作（比如点击旁边的 <code>UserList</code>）可能会切换 <code>UserDashboard</code> 的目标用户，那么问题就来了：当目标用户切换的时候，<code>UserDashboard</code> 仅仅是一个普通的<strong>更新</strong>操作，触发的是 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>componentDidUpdate</code> 这一套方法。我们需要在 <code>componentWillReceiveProps</code> 中做太多的事情：检测这次 props 的更新是否改变了用户的 ID，如果是的话，我们需要检查 <code>UserDashboard</code> 发出去的请求是否都得到了响应，对还未收到响应的请求注销其响应函数（否则上一个用户的在线状态有可能显示在这一个用户上）；我们还要更新 <code>UserDashboard</code> 上的几乎所有状态（切换用户的时候总要把聊天框关闭吧）；如果我们还不幸地用的 <code>ref</code> 做了一些神奇的 hack，那么你还要去手动把之前做的事情复原回来，这简直要成一团乱麻了！当 <code>UserDashborad</code> 的逻辑，你的 <code>componentWillReceiveProps</code> 方法里会充斥着晦涩难懂的只有你能看懂的代码（两周后你自己也看不懂了）。</p>
<p>解决方案是什么？就是用 <code>key</code> 属性。在 JSX 中使用 <code>UserDashboard</code> 的时候，不仅把 <code>userInfo</code> 传入，把 <code>userInfo.id</code> 作为名为 <code>key</code> 的 <code>props</code> 传入（尽管 <code>UserDashboard</code> 不是数组中的组件）。这样切换目标用户的时候，<code>key</code> 属性也变了，React 会自动销毁之前的组件，用一个全新的组件来渲染新的用户：我们可以从容地在 <code>componentWillUnmount</code> 里作清理工作（注销请求的响应函数，防止其更新一个 unmounted component），至于重置 <code>state</code> 这些工作已经不需要做了，由于组件不再是更新，而是销毁和重建，已经是天然完成的。</p>
<p>当然，你可以质疑这样做是否会影响性能。我认为，只要目标用户的切换不够频繁，对性能的影响是很小的。如果不使用 <code>key</code> 触发组件的销毁和重建，任由组件自行「更新」，每次切换时更新的内容也是很多的。这时，我们使用 <code>key</code> 带来的性能损耗是完全可以接受的，而带来的收益却非常大。</p>
<p>所以，我想说的结论是：为了组件内部逻辑的清晰，你几乎应该在任何复杂的有状态组件（尤其是有具体<strong>对应</strong>对象的）上使用<code>key</code>属性（只要 <code>key</code> 属性的改变不是很频繁），这样做，才能在合适的时候触发组件的销毁与重建，组件才能有一个健康的生命周期。</p>
<blockquote>
<p>题外话</p>
<p>配合 react-router 时，通常要为 route 组件赋 key，但通常情况下我们是没法传 props 给 route 组件的。解决的方案是 <code>createElement</code> 方法，如下所示。</p>
<pre><code>class App extends Component {
  static createElement = (Component, ownProps) =&gt; {
    const {userId} = ownProps.params;
    switch (Component) {
      case UserDashboard:
        return &lt;Component key={userId} {...ownProps}/&gt;;
      default:
        return &lt;Component {...ownProps}/&gt;;
    }
  };
  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;Router createElement={App.createElement} 
                history={syncHistoryWithStore(hashHistory, store)}&gt;
          &lt;Route path=&quot;/&quot; component={Home}&gt;
            &lt;IndexRoute component={Index}/&gt;
            &lt;Route path=&quot;users/:userId&quot; component={UserDashboard}/&gt;
          &lt;/Route&gt;
        &lt;/Router&gt;
      &lt;/Provider&gt;
    )
  }
}
</code></pre></blockquote>
<p>（完）</p>
]]></description>
            <link>http://xieguanglei.github.io/post/react-tips-key.html</link>
            <guid isPermaLink="false">react-tips-key</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Mon, 15 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：react-redux 之 connect 方法详解]]></title>
            <description><![CDATA[<h1 id="react-react-redux-connect-">React 实践心得：react-redux 之 connect 方法详解</h1>
<p>Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。</p>
<p>react-redux 提供了两个重要的对象，<code>Provider</code> 和 <code>connect</code>，前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对 <code>connect</code> 的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。</p>
<p>在使用了一段时间 redux 后，本文尝试再次回到这里，给<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">这段文档</a>（同时摘抄在附录中）一个靠谱的解读。</p>
<h2 id="-">预备知识</h2>
<p>首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去<a href="https://github.com/reactjs/redux/blob/master/docs/README.md">阅读一下</a>。</p>
<pre><code class="lang-jsx">const reducer = (state = {count: 0}, action) =&gt; {
  switch (action.type){
    case &#39;INCREASE&#39;: return {count: state.count + 1};
    case &#39;DECREASE&#39;: return {count: state.count - 1};
    default: return state;
  }
}

const actions = {
  increase: () =&gt; ({type: &#39;INCREASE&#39;}),
  decrease: () =&gt; ({type: &#39;DECREASE&#39;})
}

const store = createStore(reducer);

store.subscribe(() =&gt;
  console.log(store.getState())
);

store.dispatch(actions.increase()) // {count: 1}
store.dispatch(actions.increase()) // {count: 2}
store.dispatch(actions.increase()) // {count: 3}
</code></pre>
<p>通过 <code>reducer</code> 创建一个 <code>store</code>，每当我们在 <code>store</code> 上 <code>dispatch</code> 一个 <code>action</code>，<code>store</code> 内的数据就会相应地发生变化。</p>
<p>我们当然可以<strong>直接</strong>在 React 中使用 Redux：在最外层容器组件中初始化 <code>store</code>，然后将 <code>state</code> 上的属性作为 <code>props</code> 层层传递下去。</p>
<pre><code class="lang-jsx">class App extends Component{

  componentWillMount(){
    store.subscribe((state)=&gt;this.setState(state))
  }

  render(){
    return &lt;Comp state={this.state}
                 onIncrease={()=&gt;store.dispatch(actions.increase())}
                 onDecrease={()=&gt;store.dispatch(actions.decrease())}
    /&gt;
  }
}
</code></pre>
<p>但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的 <code>Provider</code> 和 <code>connect</code> 方法。</p>
<h2 id="-react-redux">使用 react-redux</h2>
<p>首先在最外层容器中，把所有内容包裹在 <code>Provider</code> 组件中，将之前创建的 <code>store</code> 作为 <code>prop</code> 传给 <code>Provider</code>。</p>
<pre><code class="lang-jsx">const App = () =&gt; {
  return (
    &lt;Provider store={store}&gt;
      &lt;Comp/&gt;
    &lt;/Provider&gt;
  )
};
</code></pre>
<p><code>Provider</code> 内的任何一个组件（比如这里的 <code>Comp</code>），如果需要使用 <code>state</code> 中的数据，就必须是「被 connect 过的」组件——使用 <code>connect</code> 方法对「你编写的组件（<code>MyComp</code>）」进行包装后的产物。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  // content...
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>可见，<code>connect</code> 方法是重中之重。</p>
<h2 id="-connect-"><code>connect</code> 详解</h2>
<p>究竟 <code>connect</code> 方法到底做了什么，我们来一探究竟。</p>
<p>首先看下函数的签名：</p>
<blockquote>
<p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
</blockquote>
<p><code>connect()</code> 接收四个参数，它们分别是 <code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>和<code>options</code>。</p>
<h3 id="-mapstatetoprops-state-ownprops-stateprops-"><code>mapStateToProps(state, ownProps) : stateProps</code></h3>
<p>这个函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    count: state.count
  }
}
</code></pre>
<p>这个函数的第一个参数就是 Redux 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>MyComp</code> 会有名为 <code>count</code> 的 <code>props</code> 字段。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  render(){
    return &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
  }
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>当然，你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    greaterThanFive: state.count &gt; 5
  }
}
</code></pre>
<p>函数的第二个参数 <code>ownProps</code>，是 <code>MyComp</code> 自己的 <code>props</code>。有的时候，<code>ownProps</code> 也会对其产生影响。比如，当你在 <code>store</code> 中维护了一个用户列表，而你的组件 <code>MyComp</code> 只关心一个用户（通过 <code>props</code> 中的 <code>userId</code> 体现）。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state, ownProps) =&gt; {
  // state 是 {userList: [{id: 0, name: &#39;王二&#39;}]}
  return {
    user: _.find(state.userList, {id: ownProps.userId})
  }
}

class MyComp extends Component {

  static PropTypes = {
    userId: PropTypes.string.isRequired,
    user: PropTypes.object
  };

  render(){
    return &lt;div&gt;用户名：{this.props.user.name}&lt;/div&gt;
  }
}

const Comp = connect(mapStateToProps)(MyComp);
</code></pre>
<p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。</p>
<p>这就是将 Redux <code>store</code> 中的数据连接到组件的基本方式。</p>
<h3 id="-mapdispatchtoprops-dispatch-ownprops-dispatchprops-"><code>mapDispatchToProps(dispatch, ownProps): dispatchProps</code></h3>
<p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 action 作为 <code>props</code> 绑定到 <code>MyComp</code> 上。</p>
<pre><code class="lang-jsx">const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return {
    increase: (...args) =&gt; dispatch(actions.increase(...args)),
    decrease: (...args) =&gt; dispatch(actions.decrease(...args))
  }
}

class MyComp extends Component {
  render(){
    const {count, increase, decrease} = this.props;
    return (&lt;div&gt;
      &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
      &lt;button onClick={increase}&gt;增加&lt;/button&gt;
      &lt;button onClick={decrease}&gt;减少&lt;/button&gt;
    &lt;/div&gt;)
  }
}

const Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);
</code></pre>
<p>由于 <code>mapDispatchToProps</code> 方法返回了具有 <code>increase</code> 属性和 <code>decrease</code> 属性的对象，这两个属性也会成为 <code>MyComp</code> 的 <code>props</code>。</p>
<p>如上所示，调用 <code>actions.increase()</code> 只能得到一个 <code>action</code> 对象 <code>{type:&#39;INCREASE&#39;}</code>，要触发这个 <code>action</code> 必须在 <code>store</code> 上调用 <code>dispatch</code> 方法。<code>diapatch</code> 正是 <code>mapDispatchToProps</code> 的第一个参数。但是，为了不让 <code>MyComp</code> 组件感知到 <code>dispatch</code> 的存在，我们需要将 <code>increase</code> 和 <code>decrease</code> 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 <code>dispatch</code>）。</p>
<p>Redux 本身提供了 <code>bindActionCreators</code> 函数，来将 action 包装成直接可被调用的函数。</p>
<pre><code class="lang-jsx">import {bindActionCreators} from &#39;redux&#39;;

const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return bindActionCreators({
    increase: action.increase,
    decrease: action.decrease
  });
}
</code></pre>
<p>同样，当 <code>ownProps</code> 变化的时候，该函数也会被调用，生成一个新的 <code>dispatchProps</code>，（在与 <code>statePrope</code> 和 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。注意，<code>action</code> 的变化不会引起上述过程，默认 <code>action</code> 在组件的生命周期中是固定的。</p>
<h3 id="-mergeprops-stateprops-dispatchprops-ownprops-props-"><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></h3>
<p>之前说过，不管是 <code>stateProps</code> 还是 <code>dispatchProps</code>，都需要和 <code>ownProps</code> merge 之后才会被赋给 <code>MyComp</code>。<code>connect</code> 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，<code>connect</code> 就会使用 <code>Object.assign</code> 替代该方法。</p>
<h3 id="-">其他</h3>
<p>最后还有一个 <code>options</code> 选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。</p>
<p>（完）</p>
<h2 id="-connect-">附：connect 方法的官方英文文档</h2>
<blockquote>
<h4 id="-connect-mapstatetoprops-mapdispatchtoprops-mergeprops-options-"><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h4>
<p>Connects a React component to a Redux store.</p>
<p>It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function): If specified, the component will subscribe to Redux store updates. Any time it updates, mapStateToProps will be called. Its result must be a plain object*, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).</p>
</li>
<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.</p>
</li>
<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.</p>
</li>
<li><p>[options] (Object) If specified, further customizes the behavior of the connector.</p>
<ul>
<li>[pure = true] (Boolean): If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Defaults to true.</li>
<li>[withRef = false] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Defaults to false.</li>
</ul>
</li>
</ul>
</blockquote>
]]></description>
            <link>http://xieguanglei.github.io/post/react-tips-connect.html</link>
            <guid isPermaLink="false">react-tips-connect</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Sun, 14 Aug 2016 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>