<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[一叶斋]]></title>
        <description><![CDATA[一叶障目 一叶知秋]]></description>
        <link>http://xieguanglei.github.io/blog/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sun, 21 Aug 2016 02:55:45 GMT</lastBuildDate>
        <atom:link href="http://xieguanglei.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[React 实践心得：key 属性的原理和用法]]></title>
            <description><![CDATA[<h1 id="react-key-">React 实践心得：key 属性的原理和用法</h1>
<p>我们知道，React 元素可以具有一个特殊的属性 key，这个属性不是给用户自己用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p>
<p>如果你有下面这样的代码：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 没有提供 key
  &lt;/div&gt;
);
</code></pre>
<p>React 会在控制台打印出报警信息：</p>
<blockquote>
<p>Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of <code>App</code>. See <a href="https://fb.me/react-warning-keys">https://fb.me/react-warning-keys</a> for more information.</p>
</blockquote>
<p>你必须为数组中的元素提供唯一的 <code>key</code> 属性，就像下面这样：</p>
<pre><code class="lang-jsx">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {props.users.map(u =&gt; &lt;div key={u.id}&gt;{u.id}:{u.name}&lt;/div&gt;)}  // 提供了 key
  &lt;/div&gt;
);
</code></pre>
<p>为什么呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如 UserList 组件的 users 属性改变了，就得重新渲染 UserList 组件，包括外部的 <code>&lt;div&gt;</code>（容器），内部的一个 <code>&lt;h3&gt;</code> 和若干个 <code>&lt;div&gt;</code>（每一个描述一个用户）。</p>
<p>对后一种 <code>&lt;div&gt;</code>（表示用户的），由于其处在一个长度不确定的数组中，React 需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。比如以下几种情况：</p>
<ul>
<li><code>[{name: &#39;张三&#39;, age: 20}]</code> =&gt; <code>[{name: &#39;张三&#39;, age: 21}]</code>：这种情况明显只需要更新元素，没有必要重新创建元素。因为人还是那个人，除了 age，其他信息没有变，显示用户姓名的那个（更小的）元素，是不需要更新（被 ReactDOM 操作到）的。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> 这种情况，显然需要添加一个新元素来表示李四，这个新元素对应的 DOM 元素会被插入到页面中。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}]</code>：这种情况就有点复杂了，似乎两种方案都可以。可以把表示张三的元素删掉，为李四新建一个，当然是非常合理的选择。但是直接把张三的元素换成李四，似乎也无不可。</li>
</ul>
<p>实际上，如果真的认为上述第3种的后一种方案也无不可，那可是大错特错了。为什么呢：</p>
<ul>
<li>考虑这种情况：<code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}, {name: &#39;张三&#39;}]</code>，难道也需要把张三的元素更新成李四的，李四的元素更新成张三的吗？</li>
</ul>
<p>那么，为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>
<p>那么，为什么只有数组中的元素需要有唯一的 key，而其他的元素（比如上面的<code>&lt;h3&gt;用户列表&lt;/h3&gt;</code>）则不需要呢？答案是：React 有能力辨别出，更新前后元素的对应关系。这一点，也许直接看 JSX 不够明显，看 Babel 转换后的 React.createElement 则清晰很多：</p>
<pre><code class="lang-jsx">// 转换前
const element = (
  &lt;div&gt;
    &lt;h3&gt;example&lt;/h3&gt;
    {[&lt;p key={1}&gt;hello&lt;/p&gt;, &lt;p key={2}&gt;world&lt;/p&gt;]}
  &lt;/div&gt;
);

// 转换后
&quot;use strict&quot;;

var element = React.createElement(
  &quot;div&quot;,
  null,
  React.createElement(&quot;h3&quot;,null,&quot;example&quot;),
  [
    React.createElement(&quot;p&quot;,{ key: 1 },&quot;hello&quot;), 
    React.createElement(&quot;p&quot;,{ key: 2 },&quot;world&quot;)
  ]
);
</code></pre>
<p>不管 props 如何变化，数组外的每个元素始终出现在 React.createElement() 参数列表中的固定位置，这个位置就是天然的 key。</p>
<blockquote>
<p>题外话</p>
<p>初学 React 时还容易产生另一个困惑，那就是为什么 JSX 不支持 if 表达式来有选择地输出（不能这样：<code>{if(yes){ &lt;div {...props}/&gt; }}</code>），而必须采用三元运算符来完成这项工作（必须这样：<code>{yes ? &lt;div {...props}/&gt;} : null</code>）。那是因为，React 需要一个 null 去占住那个元素本来的位置。</p>
</blockquote>
<p>曾经，我天真的以为 <code>key</code> 这个元素只应在数组中使用。直到我在一个复杂的项目中写出了及其恶心的 <code>componentWillReceiveProps</code>方法。我尝试寻找销毁和重建组件，触发 <code>componentDidMount</code> 方法，重置 <code>state</code>，然后才突然发现 <code>key</code> 这个属性已经在那里了。</p>
<p>举个例子，我们有一个展示用户信息的 <code>UserDashboard</code> 组件。传给组件的 <code>props</code> 只有用户的 基本信息（ID，姓名等），而有关用户的详细信息（比如当前是否在线等）是需要请求过来的。组件内的一些操作（比如尝试与该用户聊天）也会使用请求，组件本身也有各种状态（比如是否显示聊天框）。</p>
<p>整个界面上最多只有一个 <code>UserDashboard</code>，但某些操作（比如点击旁边的 <code>UserList</code>）可能会切换 <code>UserDashboard</code> 的目标用户，那么问题就来了：当目标用户切换的时候，<code>UserDashboard</code> 仅仅是一个普通的<strong>更新</strong>操作，触发的是 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>componentDidUpdate</code> 这一套方法。我们需要在 <code>componentWillReceiveProps</code> 中做太多的事情：检测这次 props 的更新是否改变了用户的 ID，如果是的话，我们需要检查 <code>UserDashboard</code> 发出去的请求是否都得到了响应，对还未收到响应的请求注销其响应函数（否则上一个用户的在线状态有可能显示在这一个用户上）；我们还要更新 <code>UserDashboard</code> 上的几乎所有状态（切换用户的时候总要把聊天框关闭吧）；如果我们还不幸地用的 <code>ref</code> 做了一些神奇的 hack，那么你还要去手动把之前做的事情复原回来，这简直要成一团乱麻了！当 <code>UserDashborad</code> 的逻辑，你的 <code>componentWillReceiveProps</code> 方法里会充斥着晦涩难懂的只有你能看懂的代码（两周后你自己也看不懂了）。</p>
<p>解决方案是什么？就是用 <code>key</code> 属性。在 JSX 中使用 <code>UserDashboard</code> 的时候，不仅把 <code>userInfo</code> 传入，把 <code>userInfo.id</code> 作为名为 <code>key</code> 的 <code>props</code> 传入（尽管 <code>UserDashboard</code> 不是数组中的组件）。这样切换目标用户的时候，<code>key</code> 属性也变了，React 会自动销毁之前的组件，用一个全新的组件来渲染新的用户：我们可以从容地在 <code>componentWillUnmount</code> 里作清理工作（注销请求的响应函数，防止其更新一个 unmounted component），至于重置 <code>state</code> 这些工作已经不需要做了，由于组件不再是更新，而是销毁和重建，已经是天然完成的。</p>
<p>当然，你可以质疑这样做是否会影响性能。我认为，只要目标用户的切换不够频繁，对性能的影响是很小的。如果不使用 <code>key</code> 触发组件的销毁和重建，任由组件自行「更新」，每次切换时更新的内容也是很多的。这时，我们使用 <code>key</code> 带来的性能损耗是完全可以接受的，而带来的收益却非常大。</p>
<p>所以，我想说的结论是：为了组件内部逻辑的清晰，你几乎应该在任何复杂的有状态组件（尤其是有具体<strong>对应</strong>对象的）上使用<code>key</code>属性（只要 <code>key</code> 属性的改变不是很频繁），这样做，才能在合适的时候触发组件的销毁与重建，组件才能有一个健康的生命周期。</p>
<blockquote>
<p>题外话</p>
<p>配合 react-router 时，通常要为 route 组件赋 key，但通常情况下我们是没法传 props 给 route 组件的。解决的方案是 <code>createElement</code> 方法，如下所示。</p>
<pre><code>class App extends Component {
  static createElement = (Component, ownProps) =&gt; {
    const {userId} = ownProps.params;
    switch (Component) {
      case UserDashboard:
        return &lt;Component key={userId} {...ownProps}/&gt;;
      default:
        return &lt;Component {...ownProps}/&gt;;
    }
  };
  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;Router createElement={App.createElement} history={syncHistoryWithStore(hashHistory, store)}&gt;
          &lt;Route path=&quot;/&quot; component={Home}&gt;
            &lt;IndexRoute component={Index}/&gt;
            &lt;Route path=&quot;users/:userId&quot; component={UserDashboard}/&gt;
          &lt;/Route&gt;
        &lt;/Router&gt;
      &lt;/Provider&gt;
    )
  }
}
</code></pre></blockquote>
<p>（完）</p>
]]></description>
            <link>http://xieguanglei.github.io/blog/post/react-tips-key.html</link>
            <guid isPermaLink="false">react-tips-key</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Mon, 15 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：react-redux 之 connect 方法详解]]></title>
            <description><![CDATA[<h1 id="react-react-redux-connect-">React 实践心得：react-redux 之 connect 方法详解</h1>
<p>Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。</p>
<p>react-redux 提供了两个重要的对象，<code>Provider</code> 和 <code>connect</code>，前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对 <code>connect</code> 的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。</p>
<p>在使用了一段时间 redux 后，本文尝试再次回到这里，给<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">这段文档</a>（同时摘抄在附录中）一个靠谱的解读。</p>
<h2 id="-">预备知识</h2>
<p>首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去<a href="https://github.com/reactjs/redux/blob/master/docs/README.md">阅读一下</a>。</p>
<pre><code class="lang-jsx">const reducer = (state = {count: 0}, action) =&gt; {
  switch (action.type){
    case &#39;INCREASE&#39;: return {count: state.count + 1};
    case &#39;DECREASE&#39;: return {count: state.count - 1};
    default: return state;
  }
}

const actions = {
  increase: () =&gt; ({type: &#39;INCREASE&#39;}),
  decrease: () =&gt; ({type: &#39;DECREASE&#39;})
}

const store = createStore(reducer);

store.subscribe(() =&gt;
  console.log(store.getState())
);

store.dispatch(actions.increase()) // {count: 1}
store.dispatch(actions.increase()) // {count: 2}
store.dispatch(actions.increase()) // {count: 3}
</code></pre>
<p>通过 <code>reducer</code> 创建一个 <code>store</code>，每当我们在 <code>store</code> 上 <code>dispatch</code> 一个 <code>action</code>，<code>store</code> 内的数据就会相应地发生变化。</p>
<p>我们当然可以<strong>直接</strong>在 React 中使用 Redux：在最外层容器组件中初始化 <code>store</code>，然后将 <code>state</code> 上的属性作为 <code>props</code> 层层传递下去。</p>
<pre><code class="lang-jsx">class App extends Component{

  componentWillMount(){
    store.subscribe((state)=&gt;this.setState(state))
  }

  render(){
    return &lt;Comp state={this.state}
                 onIncrease={()=&gt;store.dispatch(actions.increase())}
                 onDecrease={()=&gt;store.dispatch(actions.decrease())}
    /&gt;
  }
}
</code></pre>
<p>但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的 <code>Provider</code> 和 <code>connect</code> 方法。</p>
<h2 id="-react-redux">使用 react-redux</h2>
<p>首先在最外层容器中，把所有内容包裹在 <code>Provider</code> 组件中，将之前创建的 <code>store</code> 作为 <code>prop</code> 传给 <code>Provider</code>。</p>
<pre><code class="lang-jsx">const App = () =&gt; {
  return (
    &lt;Provider store={store}&gt;
      &lt;Comp/&gt;
    &lt;/Provider&gt;
  )
};
</code></pre>
<p><code>Provider</code> 内的任何一个组件（比如这里的 <code>Comp</code>），如果需要使用 <code>state</code> 中的数据，就必须是「被 connect 过的」组件——使用 <code>connect</code> 方法对「你编写的组件（<code>MyComp</code>）」进行包装后的产物。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  // content...
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>可见，<code>connect</code> 方法是重中之重。</p>
<h2 id="-connect-"><code>connect</code> 详解</h2>
<p>究竟 <code>connect</code> 方法到底做了什么，我们来一探究竟。</p>
<p>首先看下函数的签名：</p>
<blockquote>
<p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
</blockquote>
<p><code>connect()</code> 接收四个参数，它们分别是 <code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>和<code>options</code>。</p>
<h3 id="-mapstatetoprops-state-ownprops-stateprops-"><code>mapStateToProps(state, ownProps) : stateProps</code></h3>
<p>这个函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    count: state.count
  }
}
</code></pre>
<p>这个函数的第一个参数就是 Redux 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>MyComp</code> 会有名为 <code>count</code> 的 <code>props</code> 字段。</p>
<pre><code class="lang-jsx">class MyComp extends Component {
  render(){
    return &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
  }
}

const Comp = connect(...args)(MyComp);
</code></pre>
<p>当然，你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state) =&gt; {
  return {
    greaterThanFive: state.count &gt; 5
  }
}
</code></pre>
<p>函数的第二个参数 <code>ownProps</code>，是 <code>MyComp</code> 自己的 <code>props</code>。有的时候，<code>ownProps</code> 也会对其产生影响。比如，当你在 <code>store</code> 中维护了一个用户列表，而你的组件 <code>MyComp</code> 只关心一个用户（通过 <code>props</code> 中的 <code>userId</code> 体现）。</p>
<pre><code class="lang-jsx">const mapStateToProps = (state, ownProps) =&gt; {
  // state 是 {userList: [{id: 0, name: &#39;王二&#39;}]}
  return {
    user: _.find(state.userList, {id: ownProps.userId})
  }
}

class MyComp extends Component {

  static PropTypes = {
    userId: PropTypes.string.isRequired,
    user: PropTypes.object
  };

  render(){
    return &lt;div&gt;用户名：{this.props.user.name}&lt;/div&gt;
  }
}

const Comp = connect(mapStateToProps)(MyComp);
</code></pre>
<p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。</p>
<p>这就是将 Redux <code>store</code> 中的数据连接到组件的基本方式。</p>
<h3 id="-mapdispatchtoprops-dispatch-ownprops-dispatchprops-"><code>mapDispatchToProps(dispatch, ownProps): dispatchProps</code></h3>
<p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 action 作为 <code>props</code> 绑定到 <code>MyComp</code> 上。</p>
<pre><code class="lang-jsx">const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return {
    increase: (...args) =&gt; dispatch(actions.increase(...args)),
    decrease: (...args) =&gt; dispatch(actions.decrease(...args))
  }
}

class MyComp extends Component {
  render(){
    const {count, increase, decrease} = this.props;
    return (&lt;div&gt;
      &lt;div&gt;计数：{this.props.count}次&lt;/div&gt;
      &lt;button onClick={increase}&gt;增加&lt;/button&gt;
      &lt;button onClick={decrease}&gt;减少&lt;/button&gt;
    &lt;/div&gt;)
  }
}

const Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);
</code></pre>
<p>由于 <code>mapDispatchToProps</code> 方法返回了具有 <code>increase</code> 属性和 <code>decrease</code> 属性的对象，这两个属性也会成为 <code>MyComp</code> 的 <code>props</code>。</p>
<p>如上所示，调用 <code>actions.increase()</code> 只能得到一个 <code>action</code> 对象 <code>{type:&#39;INCREASE&#39;}</code>，要触发这个 <code>action</code> 必须在 <code>store</code> 上调用 <code>dispatch</code> 方法。<code>diapatch</code> 正是 <code>mapDispatchToProps</code> 的第一个参数。但是，为了不让 <code>MyComp</code> 组件感知到 <code>dispatch</code> 的存在，我们需要将 <code>increase</code> 和 <code>decrease</code> 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 <code>dispatch</code>）。</p>
<p>Redux 本身提供了 <code>bindActionCreators</code> 函数，来将 action 包装成直接可被调用的函数。</p>
<pre><code class="lang-jsx">import {bindActionCreators} from &#39;redux&#39;;

const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  return bindActionCreators({
    increase: action.increase,
    decrease: action.decrease
  });
}
</code></pre>
<p>同样，当 <code>ownProps</code> 变化的时候，该函数也会被调用，生成一个新的 <code>dispatchProps</code>，（在与 <code>statePrope</code> 和 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。注意，<code>action</code> 的变化不会引起上述过程，默认 <code>action</code> 在组件的生命周期中是固定的。</p>
<h3 id="-mergeprops-stateprops-dispatchprops-ownprops-props-"><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></h3>
<p>之前说过，不管是 <code>stateProps</code> 还是 <code>dispatchProps</code>，都需要和 <code>ownProps</code> merge 之后才会被赋给 <code>MyComp</code>。<code>connect</code> 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，<code>connect</code> 就会使用 <code>Object.assign</code> 替代该方法。</p>
<h3 id="-">其他</h3>
<p>最后还有一个 <code>options</code> 选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。</p>
<p>（完）</p>
<h2 id="-connect-">附：connect 方法的官方英文文档</h2>
<blockquote>
<h4 id="-connect-mapstatetoprops-mapdispatchtoprops-mergeprops-options-"><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h4>
<p>Connects a React component to a Redux store.</p>
<p>It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function): If specified, the component will subscribe to Redux store updates. Any time it updates, mapStateToProps will be called. Its result must be a plain object*, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).</p>
</li>
<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.</p>
</li>
<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.</p>
</li>
<li><p>[options] (Object) If specified, further customizes the behavior of the connector.</p>
<ul>
<li>[pure = true] (Boolean): If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Defaults to true.</li>
<li>[withRef = false] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Defaults to false.</li>
</ul>
</li>
</ul>
</blockquote>
]]></description>
            <link>http://xieguanglei.github.io/blog/post/react-tips-connect.html</link>
            <guid isPermaLink="false">react-tips-connect</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Sun, 14 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[React 实践心得：说说 children 的使用]]></title>
            <description><![CDATA[<h1 id="react-children-">React 实践心得：说说 children 的使用</h1>
<p>React 的初学者通常会犯一个错误是：不大会使用（甚至完全不使用）组件的 children 属性。其实，对 children 的合理使用，是「组件化」的基础。</p>
<p>这篇短文就通过一个例子，说说应该怎样合理地使用 children。</p>
<p>假设我们要做下图所示的一个用户列表组件：具体要求是这样的：</p>
<ul>
<li>顶部有「用户列表」的字样。</li>
<li>用户列表中应显示用户的头像，名称，描述，还有一个关注按钮。</li>
<li>用户的描述信息默认不显示，鼠标 hover 到用户头像上时，用气泡显示描述信息。</li>
<li>点击「关注」按钮即可关注用户，随之按钮文案变成「取关」（取消关注）。</li>
</ul>
<p><img src="https://img.alicdn.com/tps/TB1_AceLXXXXXXHXpXXXXXXXXXX-200-271.png" alt="原型图"></p>
<p>首先拆解一下上面的原型：</p>
<ul>
<li>我们首先需要一个用户列表 UserList，它在最外层。</li>
<li>UserList 组件中有一组用户信息组件 UserItem。</li>
<li>用户信息组件包括头像 Avatar，名字 Name，描述 Description，关注按钮 FollowButton。</li>
</ul>
<p><img src="https://img.alicdn.com/tps/TB1OU.rLXXXXXXBXFXXXXXXXXXX-754-415.png" alt=""></p>
<p><code>UserList</code> 会被其外层容器组件调用。如果你对 React 和「组件化」思想比较缺乏经验，很有可能会写出这样的代码来。</p>
<pre><code class="lang-js">// 不好的实现
// UserList 的外层容器组件
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [{
        id: &#39;001&#39;,
        name: &#39;关羽&#39;,
        description: &#39;斩颜良诛文丑巴拉巴拉&#39;,
        avatar: &#39;https://关羽的自画像.jpg&#39;,
        followed: false  // 是否已关注
      }, ...otherUsers]
    }
  }

  doToggleFollow(id) {
    // 关注、取消关注的请求
    requestToggleFollow(id, ()=&gt;{
      const users = _.clone(this.state.users);
      const user = _.find(users, {id});
      user.followed = !user.followed;
      this.setState({users});
    })
  }

  render() {
    return (&lt;div&gt;
      &lt;UserList users={this.state.users}
                onToggleFollow={id=&gt;this.doToggleFollow(id)}
      /&gt;
    &lt;/div&gt;)
  }
}
</code></pre>
<p>用户的数据，通常是在较外层的容器维护（这里在 <code>App</code> 组件的 <code>state</code> 下），虽然现在只有 <code>UserList</code> 用到了用户数据，但如果 App 下还有其他组件，它们几乎也一定会使用这份数据。</p>
<p>总之，现在看上去好像没有什么问题。我们使用了一个「封装良好」的 <code>UserList</code> 组件，这个组件负责搞定用户列表组件内的所有事情。如果你比较敏感的话，你可能会觉得把 <code>onToggleFollow</code> 方法传给 <code>UserList</code> 这件事似乎有些不妥，那又怎样，总之 <code>render</code> 方法看上去很干净，不是吗？</p>
<p>下面我们来看 <code>UserList</code> 的实现。</p>
<pre><code class="lang-js">// 不好的实现
const UserList = props =&gt; {
  const {users, onToggleFollow} = props;
  return (
    &lt;div&gt;
      &lt;h3&gt;用户列表&lt;/h3&gt;
      {
        users.map((u, i)=&gt;
          &lt;div key={i}&gt;
            &lt;UserItem user={u} onToggleFollow={onToggleFollow}/&gt;
          &lt;/div&gt;
        )
      }
    &lt;/div&gt;
  )
};
</code></pre>
<p>我们把从外面传过来的 <code>onToggleFollow</code> 继续向里传递给了 <code>UserItem</code> 组件。虽然有点小不爽，但是我忍了！看 <code>UserItem</code> 的实现：</p>
<pre><code class="lang-js">// 不好的实现
class UserItem extends Component {
  constructor(props){
    super(props);
    this.state = {
      hover: false
    }
  }

  render() {
    const {user, onToggleFollow} = this.props;
    return (
      &lt;div&gt;
        &lt;Avatar src={user.avatar}
                onMouseEnter={()=&gt;this.setState({hover: true})}
                onMouseLeave={()=&gt;this.setState({hover: false})}
        /&gt;
        &lt;Name value={user.name}/&gt;
        &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;onToggleFollow(user.id)}/&gt;
        {this.state.hover ? &lt;Description value={user.description}/&gt; : null}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p><code>UserItem</code> 有一个状态 <code>hover</code>，表示用户的鼠标是否悬浮在头像上方。这个状态也用来判断是否显示用户的介绍 <code>Description</code> 组件。</p>
<p><code>onToggleFollow</code> 方法继续向下传递，实在是有点忍不了了！</p>
<p>最后我们看下最底层，最简单的这几个组件：<code>Avatar</code>，<code>Name</code>，<code>FollowButton</code> 和 <code>Description</code>。</p>
<pre><code class="lang-js">// 不好的实现

// user-item-avatar.js
class Avatar extends React.Component {
  componentDidMount(){
    const img = this.refs.img;
    img.addEventListener(&#39;mouseenter&#39;, this.props.onMouseEnter);
    img.addEventListener(&#39;mouseleave&#39;, this.props.onMouseLeave);
  }
  render() {
    return &lt;img ref=&quot;img&quot; src={this.props.src}/&gt;
  }
}

// user-item-name.js
const Name = props =&gt; &lt;div&gt;{props.value}&lt;/div&gt;;

// user-item-follow-button.js
const FollowButton = props =&gt; (
  &lt;button onClick={props.onClick}&gt;{props.isFollowing ? &#39;取消关注&#39; : &#39;关注&#39;}&lt;/button&gt;
);

// user-item-description.js
const Description = props =&gt; &lt;div&gt;{props.value}&lt;/div&gt;;
</code></pre>
<p>我们可以看到，<code>onToggleFollow</code> 方法从最外层的 <code>App</code> 组件开始向内传递，经过 <code>UserList</code> 和 <code>UserItem</code>，最终落在了 <code>FollowButton</code> 上。其实，这个行为（关注与否）与中间的两层组件 <code>UserList</code> 和 <code>UserItem</code> 并没有什么关系，如果某一天「关注」按钮变成了「发信」按钮，<code>UserList</code> 和 <code>UserItem</code> 不应该为此作任何修改。</p>
<p><img src="https://img.alicdn.com/tps/TB1jPQqLXXXXXXSXFXXXXXXXXXX-714-206.png" alt=""></p>
<p>也就是说，上面的这个 <code>UserList</code> 看上去把用户列表内的逻辑都封装了起来，但它并不是一个足够「组件化」的组件。一个合格的「组件化」的 <code>UserList</code> 应该能像下面这样被调用。</p>
<pre><code class="lang-js">// UserList 的外层容器组件
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [{
        id: &#39;001&#39;,
        name: &#39;关羽&#39;,
        description: &#39;斩颜良诛文丑巴拉巴拉&#39;,
        avatar: &#39;https://关羽的自画像.jpg&#39;,
        followed: false  // 是否已关注
      }, ...otherUsers]
    }
  }

  doToggleFollow(id) {
    // 关注、取消关注的请求
    requestToggleFollow(id, ()=&gt;{
      const users = _.clone(this.state.users);
      const user = _.find(users, {id});
      user.followed = !user.followed;
      this.setState({users});
    })
  }

  render() {
    return (&lt;div&gt;
        &lt;UserList&gt;{
          users.map((user, i) =&gt;
            &lt;UserItem key={i}&gt;
              &lt;Avatar src={user.avatar}/&gt;
              &lt;Name&gt;{user.name}&lt;/Name&gt;
              &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;this.doToggleFollow(user.id)}/&gt;
              &lt;Description&gt;{user.description}&lt;/Description&gt;
            &lt;/UserItem&gt;
          )
        }&lt;/UserList&gt;
    &lt;/div&gt;)
  }
}
</code></pre>
<p>对比上述两种 <code>UserList</code> 的用法，可见前者的用法虽然简单，但对调用者而言，却像一个令人不安的「黑盒子」，完全不知道 <code>UserList</code> 会在内部干出什么事情来，而且还需要传一个莫名其妙的 <code>onToggleFollow</code> 函数。</p>
<p>相较之下，后者的用法虽然看上去复杂一些，但是对调用者来说，组件内部的结构更加清晰，也更容易掌控。数据和行为都显而易见地绑定在与之直接关联的组件上，用户根本不需要查看 <code>UserList</code> 的实现代码就能很清楚地知道，这个组件的真正功能。</p>
<p>而这两种组件的差别，最表面的就是是否使用了 <code>children</code> 属性。</p>
<pre><code class="lang-js">// 第一种用法
render() {
  return (&lt;div&gt;
    &lt;UserList users={this.state.users}
              onToggleFollow={id=&gt;this.doToggleFollow(id)}
    /&gt;
  &lt;/div&gt;)
}

// 第二种用法
render() {
  return (&lt;div&gt;
    &lt;UserList&gt;{
      users.map((user, i) =&gt;
        &lt;UserItem key={i}&gt;
          &lt;Avatar src={user.avatar}/&gt;
          &lt;Name&gt;{user.name}&lt;/Name&gt;
          &lt;FollowButton isFollowing={user.followed} onClick={()=&gt;this.doToggleFollow(user.id)}/&gt;
          &lt;Description&gt;{user.description}&lt;/Description&gt;
        &lt;/UserItem&gt;
      )
    }&lt;/UserList&gt;
  &lt;/div&gt;)
}
</code></pre>
<p>实现第二种 <code>UserList</code>，需要在渲染组件的时候，在特定的「坑位」上加上 <code>this.props.children</code>。如下所示：</p>
<pre><code class="lang-js">const UserList = props =&gt; (
  &lt;div&gt;
    &lt;h3&gt;用户列表&lt;/h3&gt;
    {this.props.children}
  &lt;/div&gt;
);
</code></pre>
<p><code>UserItem</code> 相对会复杂一些：</p>
<pre><code class="lang-js">class UserItem extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hover: false
    }
  }

  render() {
    const {children: [avatar, name, followButton, description]} = this.props;
    const onMouseEnter = () =&gt; this.setState({hover: true});
    const onMouseLeave = () =&gt; this.setState({hover: false});
    return (
      &lt;div&gt;
        {React.cloneElement(avatar, {onMouseEnter, onMouseLeave})}
        {name}
        {followButton}
        {this.state.hover ? description : null}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>由于我们在 <code>UserItem</code> 内部放了多个组件，所以在 <code>UserItem</code> 中，<code>children</code> 是一个数组，需要对数组中的每一个元素进行额外处理。</p>
<p>第1个元素是头像 <code>avatar</code>，它的 hover 状态影响到用户描述的显示与否，所以需要在这一步绑定事件。但是 ReactElemnt 是不可改变（immutable）的，我们使用 <code>React.cloneElement</code> 创建了一个新的 ReactElement。</p>
<p>第4个元素的显示与否，取决于 <code>state.hover</code>，十分合理。</p>
<p>最后，我们可以总结一下，<code>UserList</code> 组件对于用户的直观感受：</p>
<p>第一种实现：</p>
<ul>
<li>用户列表 UserList：<ul>
<li>需要传入用户数据（用户数据里的结构不大清楚）。</li>
<li>还需要传入一个不知干什么的函数（研究了一下，应该是点击关注按钮后调用）。</li>
</ul>
</li>
</ul>
<p>第二种实现：</p>
<ul>
<li>用户列表 UserList：<ul>
<li>其中包括 UserItem 的列表。</li>
</ul>
</li>
<li>用户信息 UserItem：<ul>
<li>包括用户头像 Avatar，数据来源于 user.avatar。</li>
<li>包括用户名字 Name，数据来源于 user.name。</li>
<li>包括一个按钮 FollowButton，需要设定 user.isFollowing 状态，用户点击后调用函数进行关注/取关。</li>
<li>包括用户描述 Description，数据来源于 user.description。</li>
<li>发现只有鼠标 hover 在头像上时才会显示出来，但是我可以不需要关心这件事。</li>
</ul>
</li>
</ul>
<p>很显然，上面的第二种实现方案确实比第一种的质量高很多。</p>
]]></description>
            <link>http://xieguanglei.github.io/blog/post/react-tips-children.html</link>
            <guid isPermaLink="false">react-tips-children</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Thu, 04 Aug 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Canvas 最佳实践（性能篇）]]></title>
            <description><![CDATA[<h1 id="canvas-">Canvas 最佳实践（性能篇）</h1>
<p>Canvas 想必前端同学们都不陌生，它是 HTML5 新增的「画布」元素，允许我们使用 JavaScript 来绘制图形。目前，所有的主流浏览器都支持 Canvas。</p>
<p><img src="http://img.alicdn.com/tps/TB1YgYILpXXXXcXXFXXXXXXXXXX-764-261.jpg" alt="Canvas兼容性"></p>
<p>Canvas 最常见的用途是渲染动画。渲染动画的基本原理，无非是反复地擦除和重绘。为了动画的流畅，留给我渲染一帧的时间，只有短短的 16ms。在这 16ms 中，我不仅需要处理一些游戏逻辑，计算每个对象的位置、状态，还需要把它们都画出来。如果消耗的时间稍稍多了一些，用户就会感受到「卡顿」。所以，在编写动画（和游戏）的时候，我无时无刻不担忧着动画的性能，唯恐对某个 API 的调用过于频繁，导致渲染的耗时延长。</p>
<p>为此，我做了一些实验，查阅了一些资料，整理了平时使用 Canvas 的若干心得体会，总结出这一片所谓的「最佳实践」。如果你和我有类似的困扰，希望本文对你有一些价值。</p>
<blockquote>
<p>本文仅讨论 Canvas 2D 相关问题。</p>
</blockquote>
<h1 id="-">计算与渲染</h1>
<p>把动画的一帧渲染出来，需要经过以下步骤：</p>
<ol>
<li>计算：处理游戏逻辑，计算每个对象的状态，不涉及 DOM 操作（当然也包含对 Canvas 上下文的操作）。</li>
<li>渲染：真正把对象绘制出来。
2.1. JavaScript 调用 DOM API（包括 Canvas API）以进行渲染。
2.2. 浏览器（通常是另一个渲染线程）把渲染后的结果呈现在屏幕上的过程。</li>
</ol>
<p><img src="http://img.alicdn.com/tps/TB1i6rMLpXXXXaZXFXXXXXXXXXX-593-323.png" alt=""></p>
<blockquote>
<p>之前曾说过，留给我们渲染每一帧的时间只有 16ms。然而，其实我们所做的只是上述的步骤中的 1 和 2.1，而步骤 2.2 则是浏览器在另一个线程（至少几乎所有现代浏览器是这样的）里完成的。动画流畅的真实前提是，以上所有工作都在 16ms 中完成，所以 JavaScript 层面消耗的时间最好控制在 10ms 以内。</p>
</blockquote>
<p>虽然我们知道，通常情况下，渲染比计算的开销大很多（3~4个量级）。除非我们用到了一些时间复杂度很高的算法（这一点在本文最后一节讨论），计算环节的优化没有必要深究。</p>
<p>我们需要深入研究的，是如何优化渲染的性能。而优化渲染性能的总体思路很简单，归纳为以下几点：</p>
<ol>
<li>在每一帧中，尽可能减少调用渲染相关 API 的次数（通常是以计算的复杂化为代价的）。</li>
<li>在每一帧中，尽可能调用那些渲染开销较低的 API。</li>
<li>在每一帧中，尽可能以「导致渲染开销较低」的方式调用渲染相关 API。</li>
</ol>
<h1 id="canvas-">Canvas 上下文是状态机</h1>
<p>Canvas API 都在其上下文对象 <code>context</code> 上调用。</p>
<pre><code class="lang-javascript">var context = canvasElement.getContext(&#39;2d&#39;);
</code></pre>
<p>我们需要知道的第一件事就是，<code>context</code> 是一个状态机。你可以改变 <code>context</code> 的若干状态，而几乎所有的渲染操作，最终的效果与 <code>context</code> 本身的状态有关系。比如，调用 <code>strokeRect</code> 绘制的矩形边框，边框宽度取决于 <code>context</code> 的状态 <code>lineWidth</code>，而后者是之前设置的。</p>
<pre><code class="lang-javascript">context.lineWidth = 5;
context.strokeColor = &#39;rgba(1, 0.5, 0.5, 1)&#39;;

context.strokeRect(100, 100, 80, 80);
</code></pre>
<p><img src="http://img.alicdn.com/tps/TB1M4vNLpXXXXarXFXXXXXXXXXX-407-348.png" alt=""></p>
<p>说到这里，和性能貌似还扯不上什么关系。那我现在就要告诉你，对 <code>context.lineWidth</code> 赋值的开销远远大于对一个普通对象赋值的开销，你会作如何感想。</p>
<p>当然，这很容易理解。Canvas 上下文不是一个普通的对象，当你调用了 <code>context.lineWidth = 5</code> 时，浏览器会需要立刻地做一些事情，这样你下次调用诸如 <code>stroke</code> 或 <code>strokeRect</code> 等 API 时，画出来的线就正好是 5 个像素宽了（不难想象，这也是一种优化，否则，这些事情就要等到下次 <code>stroke</code> 之前做，更加会影响性能）。</p>
<p>我尝试执行以下赋值操作 10<sup>6</sup> 次，得到的结果是：对一个普通对象的属性赋值只消耗了 3ms，而对 <code>context</code> 的属性赋值则消耗了 40ms。值得注意的是，如果你赋的值是非法的，浏览器还需要一些额外时间来处理非法输入，正如第三/四种情形所示，消耗了 140ms 甚至更多。</p>
<pre><code>somePlainObject.lineWidth = 5;  // 3ms (10^6 times)
context.lineWidth = 5;  // 40ms
context.lineWidth = &#39;Hello World!&#39;; // 140ms
context.lineWidth = {}; // 600ms
</code></pre><p>对 <code>context</code> 而言，对不同属性的赋值开销也是不同的。<code>lineWidth</code> 只是开销较小的一类。下面整理了为 <code>context</code> 的一些其他的属性赋值的开销，如下所示。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>开销</th>
<th>开销（非法赋值）</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>line[Width/Join/Cap]</code></td>
<td>40+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>[fill/stroke]Style</code></td>
<td>100+</td>
<td>200+</td>
</tr>
<tr>
<td> <code>font</code></td>
<td>1000+</td>
<td>1000+</td>
</tr>
<tr>
<td> <code>text[Align/Baseline]</code></td>
<td>60+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>shadow[Blur/OffsetX]</code></td>
<td>40+</td>
<td>100+</td>
</tr>
<tr>
<td> <code>shadowColor</code></td>
<td>280+</td>
<td>400+</td>
</tr>
</tbody>
</table>
<p>与真正的绘制操作相比，改变 <code>context</code> 状态的开销已经算比较小了，毕竟我们还没有真正开始绘制操作。我们需要了解，改变 <code>context</code> 的属性并非是完全无代价的。我们可以通过适当地安排调用绘图 API 的顺序，降低 <code>context</code> 状态改变的频率。</p>
<h1 id="-canvas">分层 Canvas</h1>
<p>分层 Canvas 在几乎任何动画区域较大，动画较复杂的情形下都是非常有必要的。分层 Canvas 能够大大降低完全不必要的渲染性能开销。分层渲染的思想被广泛用于图形相关的领域：从古老的皮影戏、套色印刷术，到现代电影/游戏工业，虚拟现实领域，等等。而分层 Canvas 只是分层渲染思想在 Canvas 动画上最最基本的应用而已。</p>
<p><img src="http://img.alicdn.com/tps/TB1RgLULpXXXXatXVXXXXXXXXXX-667-309.png" alt="分层Canvas"></p>
<p>分层 Canvas 的出发点是，动画中的每种元素（层），对渲染和动画的要求是不一样的。对很多游戏而言，主要角色变化的频率和幅度是很大的（他们通常都是走来走去，打打杀杀的），而背景变化的频率或幅度则相对较小（基本不变，或者缓慢变化，或者仅在某些时机变化）。很明显，我们需要很频繁地更新和重绘人物，但是对于背景，我们也许只需要绘制一次，也许只需要每隔 200ms 才重绘一次，绝对没有必要每 16ms 就重绘一次。</p>
<blockquote>
<p>对于 Canvas 而言，能够在每层 Canvas 上保持不同的重绘频率已经是最大的好处了。然而，分层思想所解决的问题远不止如此。</p>
</blockquote>
<p>使用上，分层 Canvas 也很简单。我们需要做的，仅仅是生成多个 Canvas 实例，把它们重叠放置，每个 Canvas 使用不同的 z-index 来定义堆叠的次序。然后仅在需要绘制该层的时候（也许是「永不」）进行重绘。</p>
<pre><code class="lang-javascript">var contextBackground = canvasBackground.getContext(&#39;2d&#39;);
var contextForeground = canvasForeground.getContext(&#39;2d&#39;);

function render(){
  drawForeground(contextForeground);
  if(needUpdateBackground){
    drawBackground(contextBackground);
  }
  requestAnimationFrame(render);
}
</code></pre>
<p>记住，堆叠在上方的 Canvas 中的内容会覆盖住下方 Canvas 中的内容。</p>
<h1 id="-">绘制图像</h1>
<p>目前，Canvas 中使用到最多的 API，非 <code>drawImage</code> 莫属了。（当然也有例外，你如果要用 Canvas 写图表，自然是半句也不会用到了）。</p>
<p><code>drawImage</code> 方法的格式如下所示：</p>
<pre><code>context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
</code></pre><p><img src="http://gw.alicdn.com/tps/TB11l3dLpXXXXXRXpXXXXXXXXXX-593-395.png" alt=""></p>
<h2 id="-">数据源与绘制的性能</h2>
<p>由于我们具备「把图片中的某一部分绘制到 Canvas 上」的能力，所以很多时候，我们会把多个游戏对象放在一张图片里面，以减少请求数量。这通常被称为「精灵图」。然而，这实际上存在着一些潜在的性能问题。我发现，使用 <code>drawImage</code> 绘制同样大小的区域，数据源是一张和绘制区域尺寸相仿的图片的情形，比起数据源是一张较大图片（我们只是把数据扣下来了而已）的情形，前者的开销要小一些。可以认为，两者相差的开销正是「裁剪」这一个操作的开销。</p>
<blockquote>
<p>我尝试绘制 10<sup>4</sup> 次一块 320x180 的矩形区域，如果数据源是一张 320x180 的图片，花费了 40ms，而如果数据源是一张 800x800 图片中裁剪出来的 320x180 的区域，需要花费 70ms。</p>
</blockquote>
<p>虽然看上去开销相差并不多，但是 <code>drawImage</code> 是最常用的 API 之一，我认为还是有必要进行优化的。优化的思路是，将「裁剪」这一步骤事先做好，保存起来，每一帧中仅绘制不裁剪。具体的，在「离屏绘制」一节中再详述。</p>
<h2 id="-">视野之外的绘制</h2>
<p>有时候，Canvas 只是游戏世界的一个「窗口」，如果我们在每一帧中，都把整个世界全部画出来，势必就会有很多东西画到 Canvas 外面去了，同样调用了绘制 API，但是并没有任何效果。我们知道，判断对象是否在 Canvas 中会有额外的计算开销（比如需要对游戏角色的全局模型矩阵求逆，以分解出对象的世界坐标，这并不是一笔特别廉价的开销），而且也会增加代码的复杂程度，所以关键是，是否值得。</p>
<p>我做了一个实验，绘制一张 320x180 的图片 10<sup>4</sup> 次，当我每次都绘制在 Canvas 内部时，消耗了 40ms，而每次都绘制在 Canvas 外时，仅消耗了 8ms。大家可以掂量一下，考虑到计算的开销与绘制的开销相差 2~3 个数量级，我认为通过计算来过滤掉哪些画布外的对象，仍然是很有必要的。</p>
<h1 id="-">离屏绘制</h1>
<p>上一节提到，绘制同样的一块区域，如果数据源是尺寸相仿的一张图片，那么性能会比较好，而如果数据源是一张大图上的一部分，性能就会比较差，因为每一次绘制还包含了裁剪工作。也许，我们可以先把待绘制的区域裁剪好，保存起来，这样每次绘制时就能轻松很多。</p>
<p><code>drawImage</code> 方法的第一个参数不仅可以接收 <code>Image</code> 对象，也可以接收另一个 <code>Canvas</code> 对象。而且，使用 <code>Canvas</code> 对象绘制的开销与使用 <code>Image</code> 对象的开销几乎完全一致。我们只需要实现将对象绘制在一个未插入页面的 <code>Canvas</code> 中，然后每一帧使用这个 <code>Canvas</code> 来绘制。</p>
<pre><code class="lang-js">// 在离屏 canvas 上绘制
var canvasOffscreen = document.createElement(&#39;canvas&#39;);
canvasOffscreen.width = dw;
canvasOffscreen.height = dh;
canvasOffscreen.getContext(&#39;2d&#39;).drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

// 在绘制每一帧的时候，绘制这个图形
context.drawImage(canvasOffscreen, x, y);
</code></pre>
<p>离屏绘制的好处远不止上述。有时候，游戏对象是多次调用 <code>drawImage</code> 绘制而成，或者根本不是图片，而是使用路径绘制出的矢量形状，那么离屏绘制还能帮你把这些操作简化为一次 <code>drawImage</code> 调用。</p>
<blockquote>
<p>第一次看到 <code>getImageData</code> 和 <code>putImageData</code> 这一对 API，我有一种错觉，它们简直就是为了上面这个场景而设计的。前者可以将某个 Canvas 上的某一块区域保存为 <code>ImageData</code> 对象，后者可以将 <code>ImageData</code> 对象重新绘制到 Canvas 上面去。但实际上，<code>putImageData</code> 是一项开销极为巨大的操作，它根本就不适合在每一帧里面去调用。</p>
</blockquote>
<h1 id="-">避免「阻塞」</h1>
<p>所谓「阻塞」，可以理解为不间断运行时间超过 16ms 的 JavaScript 代码，以及「导致浏览器花费超过 16ms 时间进行处理」的 JavaScript 代码。即使在没有什么动画的页面里，阻塞也会被用户立刻察觉到：阻塞会使页面上的对象失去响应——按钮按不下去，链接点不开，甚至标签页都无法关闭了。而在包含较多 JavaScript 动画的页面里，阻塞会使动画停止一段时间，直到阻塞恢复后才继续执行。如果经常出现「小型」的阻塞（比如上述提及的这些优化没有做好，渲染一帧的时间超过 16ms），那么就会出现「丢帧」的情况，</p>
<blockquote>
<p>CSS3 动画（<code>transition</code> 与 <code>animate</code>）不会受 JavaScript 阻塞的影响，但不是本文讨论的重点。</p>
</blockquote>
<p><img src="http://img.alicdn.com/tps/TB18QnWLpXXXXapXVXXXXXXXXXX-674-461.png" alt=""></p>
<p>偶尔的且较小的阻塞是可以接收的，频繁或较大的阻塞是不可以接受的。也就是说，我们需要解决两种阻塞：</p>
<ul>
<li>频繁（通常较小）的阻塞。其原因主要是过高的渲染性能开销，在每一帧中做的事情太多。</li>
<li>较大（虽然偶尔发生）的阻塞。其原因主要是运行复杂算法、大规模的 DOM 操作等等。</li>
</ul>
<p>对前者，我们应当仔细地优化代码，有时不得不降低动画的复杂（炫酷）程度，本文前几节中的优化方案，解决的就是这个问题。</p>
<p>而对于后者，主要有以下两种优化的策略。</p>
<ul>
<li>使用 Web Worker，在另一个线程里进行计算。</li>
<li>将任务拆分为多个较小的任务，插在多帧中进行。</li>
</ul>
<p>Web Worker 是好东西，性能很好，兼容性也不错。浏览器用另一个线程来运行 Worker 中的 JavaScript 代码，完全不会阻碍主线程的运行。动画（尤其是游戏）中难免会有一些时间复杂度比较高的算法，用 Web Worker 来运行再合适不过了。</p>
<p><img src="http://img.alicdn.com/tps/TB1qt_yLpXXXXcrXVXXXXXXXXXX-764-277.jpg" alt="Web Worker 兼容性"></p>
<p>然而，Web Worker 无法对 DOM 进行操作。所以，有些时候，我们也使用另一种策略来优化性能，那就是将任务拆分成多个较小的任务，依次插入每一帧中去完成。虽然这样做几乎肯定会使执行任务的总时间变长，但至少动画不会卡住了。</p>
<p><img src="http://gw.alicdn.com/tps/TB1UG.qLpXXXXbdXpXXXXXXXXXX-674-461.png" alt=""></p>
<p>看下面这个 <a href="http://jsbin.com/puruba/edit?html,output">Demo</a>，我们的动画是使一个红色的 <code>div</code> 向右移动。Demo 中是通过每一帧改变其 <code>transform</code> 属性完成的（Canvas 绘制操作也一样）。</p>
<p>然后，我创建了一个会阻塞浏览器的任务：获取 4x10<sup>6</sup> 次 <code>Math.random()</code> 的平均值。点击按钮，这个任务就会被执行，其结果也会打印在屏幕上。</p>
<p><img src="http://gw.alicdn.com/tps/TB13HZILpXXXXacXXXXXXXXXXXX-296-369.png" alt=""></p>
<p>如你所见，如果直接执行这个任务，动画会明显地「卡」一下。而使用 Web Worker 或将任务拆分，则不会卡。</p>
<blockquote>
<p>以上两种优化策略，有一个相同的前提，即任务是异步的。也就是说，当你决定开始执行一项任务的时候，你并不需要立刻（在下一帧）知道结果。比如，即使战略游戏中用户的某个操作触发了寻路算法，你完全可以等待几帧（用户完全感知不到）再开始移动游戏角色。
另外，将任务拆分以优化性能，会带来显著的代码复杂度的增加，以及额外的开销。有时候，我觉得也许可以考虑优先砍一砍需求。</p>
</blockquote>
<h1 id="-">小结</h1>
<p>正文就到这里，最后我们来稍微总结一下，在大部分情况下，需要遵循的「最佳实践」。</p>
<ol>
<li>将渲染阶段的开销转嫁到计算阶段之上。</li>
<li>使用多个分层的 Canvas 绘制复杂场景。</li>
<li>不要频繁设置绘图上下文的 font 属性。</li>
<li>不在动画中使用 putImageData 方法。</li>
<li>通过计算和判断，避免无谓的绘制操作。</li>
<li>将固定的内容预先绘制在离屏 Canvas 上以提高性能。</li>
<li>使用 Worker 和拆分任务的方法避免复杂算法阻塞动画运行。</li>
</ol>
]]></description>
            <link>http://xieguanglei.github.io/blog/post/canvas-best-practice-performance.html</link>
            <guid isPermaLink="false">canvas-best-practice-performance</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Mon, 25 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[骨骼动画原理与前端实现浅谈]]></title>
            <description><![CDATA[<h1 id="-">骨骼动画原理与前端实现浅谈</h1>
<p>人的运动——走，跑，跳，是由骨骼带动躯干和四肢完成的。「骨骼动画」，顾名思义，就是模拟骨骼运动的机制而制作的动画。比如下面这条奔跑的小龙。参考 <a href="http://jsbin.com/seyita/1/edit?html,output">Demo</a>。</p>
<p><img src="http://img.alicdn.com/tps/TB15qLcKFXXXXceXpXXXXXXXXXX-310-270.gif" alt="奔跑的小龙"></p>
<blockquote>
<p>素材来自开源骨骼动画编辑器 <a href="http://dragonbones.github.io/">Dragonbones</a></p>
</blockquote>
<p>用到的素材，额，其实是他大卸八块后的样子。</p>
<p><img src="http://img.alicdn.com/tps/TB1rZG9KFXXXXX3XFXXXXXXXXXX-369-272.jpg" alt="奔跑的小龙素材"></p>
<p>骨骼动画主要被用游戏场景中，做 Logo 、彩蛋也不错（比如 2014 年双 11 的喵喵舞就是天猫的同学基于骨骼动画原理实现的）。其实，在 CSS <code>transform</code> 或 Canvas 的帮助下，Web 前端播放骨骼动画，可谓举手之劳矣。</p>
<h2 id="-">组装骨骼</h2>
<p>骨骼当然不是随便排列的，它们需要以树状结构组织起来。</p>
<p><img src="http://img.alicdn.com/tps/TB17XvsKFXXXXXoXXXXXXXXXXXX-500-400.png" alt="骨骼解析"></p>
<p>光有树状的结构还是远远不够的，每片骨骼还需要描述 <strong>自身的位移是多少（x，y），旋转的角度是多少（θ）</strong> 。注意， <strong>骨骼的位移和角度是相对「父骨骼」（的坐标系）而言的</strong> 。</p>
<p>举个例子，左臂的位移是（78，-40），角度是 -30°，表示左臂在躯干的基础上，沿 X 轴平移 78，沿 Y 轴平移 -40，然后旋转 -30°，才是左臂目前的位置。同样，左前臂的位移是（-45，100），角度是 55°，表示左前臂在左臂的基础上，沿 X 轴平移 -45，沿 Y 轴平移 100，然后旋转 55°，才是左前臂的位置。依此类推。</p>
<p><img src="http://img.alicdn.com/tps/TB1umjqKFXXXXXeXFXXXXXXXXXX-439-514.png" alt="躯干-左臂-左前臂 骨骼系统"></p>
<p>位移和角度统称「变换参数」。用相对于父骨骼（而非全局）的变换参数描述子骨骼本身，其好处在于。当右臂（父骨骼）运动起来（变换参数变化起来）的时候，右前臂（子骨骼）自身即使不动（变换参数不变），它实际上还能够 <strong>随着</strong> 右臂运动。</p>
<p>先不论如何使骨骼动起来，我们先研究下，如何把组装好的静态骨骼渲染/展示出来。这里分两种情况讨论：</p>
<h3 id="dom-">DOM元素：</h3>
<p>很容易想到，用固定尺寸且绝对定位的 <code>div</code>，配合 CSS <code>transform</code> 属性实现。比如：</p>
<pre><code>&lt;div class=“躯干” style=“transform:躯干的位移和角度; position: absolute; …”&gt;
  &lt;div class=“左臂” style=“transform:左臂的位移和角度; position: absolute; …”&gt;
    &lt;div class=“左前臂” style=“..”&gt;
      &lt;div class=“左爪” style=“..”&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;!—其余部分—&gt;
&lt;/div&gt;
</code></pre><p>你看，DOM 元素被 CSS <code>transform</code> 作用时，所有子元素随之被 <code>transform</code> 了，和骨骼动画完美契合！</p>
<p>想法固然不错， <strong>但是</strong> ，请考虑一下这样一种情况：</p>
<ul>
<li>骨骼A：div A （z=1）<ul>
<li>骨骼B：div B （z=4：B显示在D前面） </li>
</ul>
</li>
<li>骨骼C：div C （z=2：C显示在A前面）<ul>
<li>骨骼D：div D （z=3）</li>
</ul>
</li>
</ul>
<p>我们知道，在 <code>position:absolute</code> 时，DOM 元素会创建自己的 Stack Context。也就是说，只要 div A 的 <code>z-index</code> 值小于了 div C，那么作为 A 的子元素 B，即使 <code>z-index</code> 大过天，也不可能覆盖 C 及其子元素。</p>
<p>所以，我们只能将所有骨骼平铺下来：</p>
<ul>
<li>骨骼A （z=1）</li>
<li>骨骼B （z=4）</li>
<li>骨骼C （z=2）</li>
<li>骨骼D （z=3）</li>
</ul>
<p>这带来了新的问题：我们所具有的 B 的变换参数，是相对其父骨骼 A 的，而在渲染时，我们需要的是 B 直接相对于最外层骨骼的位移和角度。</p>
<h3 id="canvas-">Canvas：</h3>
<p>对使用 Canvas 的情况，我们知道 <code>context.transform</code> 方法会变换当前画笔坐标系，于是很容易想到这么做。</p>
<pre><code>context.transform(躯干位置)
context.save();  // 1
  context.transform(左臂位置)
  context.draw(左臂)
    context.transform(在左臂左前臂位置)
    context.draw(左前臂)
      context.transform(左爪位置)
      context.draw(左爪)
context.restore() // 回到了 1 状态
// 继续绘制其他部分
</code></pre><p>这样做也存在问题。实际上，这种方法是按照深度优先的原则，遍历了以最外层骨骼为根的骨骼树，绘制了树上的每个节点（骨骼）。 <strong>这限制了我们绘制 Canvas 对象的顺序。</strong></p>
<p>Canvas 2D 绘图没有 3D 绘图的「深度缓存」机制，所以在 2D 绘图中，对某一个像素而言，后绘制的内容一定会覆盖（至少影响）之前绘制的内容。但是，每片骨骼的 Z 值是定义好的，它们的前后关系可不能随便乱来，要使绘制的效果和定义的相同，就先得对骨骼进行深度排序，先画后面的，再画前面的。</p>
<blockquote>
<p>深度缓存机制，可以这样理解：我「画」了，但由于这个像素之前已经画过，而且 z 值比我大，所以我硬是没「画」上去。</p>
</blockquote>
<pre><code>context.setTransform(躯干的绝对位置)
context.draw(躯干)
context.setTransform(左臂的绝对位置)
context.draw(左臂)
//  按照深度顺序进行绘制
</code></pre><p>这时，我们需要的位移和角度，便不再是相对于父骨骼的了，而是相对于最外层骨骼的。遇到的问题和使用 DOM 时一模一样。</p>
<h2 id="-">从相对到绝对</h2>
<p>仍然以躯干-左臂-左前臂系统为例。我们知道，左臂（相对躯干）的变换参数是（78，-40，-30°），左前臂（相对左臂）的变换参数是（-45，100，55°）。那么，左前臂相对躯干的变换参数如何求算呢？</p>
<blockquote>
<p>躯干也是有变换参数的，它的「父骨骼」是 Root ——一个「隐形」、「固定」的最外层骨骼，所以实际上我们需要求算相对 Root 的变换参数。不过原理是完全一致的。</p>
</blockquote>
<p>也许你会猜：左前臂相对躯干的变换参数是（78-45=33，-40+100=60，-30°+55°=25°）。这是错误的。</p>
<p>实际上，位移和旋转会相互影响，不能直接加和。这里。我们需要使用「变换矩阵」来求算（还记得 <code>transform: matrix(…)</code> 的形式吗）。对于不了解图形学基础的同学，这也许有点难，不过没关系，我们只需要知道，通过一个 3x3 的矩阵，有办法算出左前臂相对躯干的变换参数。</p>
<p>算出来的结果是 （89，69，25°）。</p>
<p><img src="http://img.alicdn.com/tps/TB159_dKFXXXXcgXVXXXXXXXXXX-439-514.png" alt=""></p>
<p>这样，我们就能在不依赖左臂的情况下，把左前臂的位置确定下来了。所有的骨骼都按照这种方式处理，万事大吉了！</p>
<h2 id="-">动起来</h2>
<p>骨骼拼装好的对象，当然是要动起来的。而骨骼动画最重要的特征，就是「父骨骼」的运动带动了所有「后代骨骼」（手臂挥舞的时候，巴掌当然要跟着动咯），所以骨骼动画才比较精致。</p>
<p>一个完整的骨骼动画的 <strong>动作</strong> ，可以分解到每片骨骼上。而每一片骨骼的动作，则由关键帧所定义。举个例子，一个跑步的动作，分解到各个骨骼上，无非包括：</p>
<ul>
<li>躯干：上下起伏。</li>
<li>腿部：抬起和落下。</li>
<li>手臂：前后摆动。</li>
<li>手前臂：肘部的弯曲变化。</li>
</ul>
<p>如果还想做细腻一些，自然还有头部的摆动，毛发颤动，眼珠转动等等……而每一片骨骼的变化，只需要三五个关键帧。比如，示例骨骼动画（小龙跑步）的关键帧定义如下图所示。每个关键帧包含的信息包括：关键帧在动画周期中的位置，以及骨骼的变换参数。</p>
<p><img src="http://img.alicdn.com/tps/TB1BqHDKFXXXXaEXXXXXXXXXXXX-546-633.png" alt="小龙跑步关键帧"></p>
<p>接下来，还有什么好说的呢？动画最基本的原理，就是随着时间更新对象的视觉状态。那么，对骨骼动画而言，就是在每一帧的时候，根据当前帧在一个动画周期内的位置，线性内插出每一片骨骼的位移和角度，然后算出全局的位移和角度，再画出来。</p>
<blockquote>
<p>内插，就是根据离散的值求取中间值的过程。最简单是线性内插，中间值仅与左右两个离散值，和中间值的位置有关。比如，当中间值位置为 0.5，左右两侧的值为 1 和 2，那么内插值就是 1.5，即 f(1, 2, 0.5) = 1.5；同理，f(1, 2, 0.7) = 1.7，f(1, 2, 0.3) = 1.3。</p>
</blockquote>
<p>如上图所示，一个动画周期的长度是 6 个单位（这里是 DragonBones 定义的长度单位，默认是 1/24 秒，实际播放时可以随意改变），那么在任意时刻（比如播放到 1 个单位时长之时），都需要根据左右最近的关键帧，内插出一个变换参数值，然后根据这个参数值，按照前一节所述的方法渲染或更新动画的状态。</p>
<p>这样，我们就能看到下面的情形了：参考 <a href="http://jsbin.com/seyita/1/edit?html,output">Demo</a>。</p>
<p><img src="http://img.alicdn.com/tps/TB15qLcKFXXXXceXpXXXXXXXXXX-310-270.gif" alt="奔跑的小龙"></p>
<h2 id="-">其他</h2>
<p>开源软件 DragonBones 是设计 2D 骨骼动画的不二之选，它支持将动画数据导出成 JSON 格式。DragonBones 中有 bone（骨骼）、slot（插槽）、skin（皮肤）的概念。骨骼本身不包含实体，只有变换（位移、旋转等）的数据，骨骼包含一些插槽，Z 值定义在插槽上，而插槽里可以插入皮肤，皮肤除了描述对应哪张图（甚至图上的某个区域），还具有变换数据（但不会变化）。这些设计即方便了设计师在软件中的操作和编辑，也方便开发者使用这份数据来播放精灵动画。</p>
<p>最后广告一下吧，<a href="http://gama.taobao.net">Gama</a> 现在也已经有了骨骼动画模块 <a href="http://gama.taobao.net/3/detail.html?name=skeleton">Gama Skeleton</a>，接入方便，使用简单，开箱即用，立等可取。</p>
<p>（完）</p>
]]></description>
            <link>http://xieguanglei.github.io/blog/post/skeleton.html</link>
            <guid isPermaLink="false">skeleton</guid>
            <dc:creator><![CDATA[谢光磊]]></dc:creator>
            <pubDate>Wed, 25 Nov 2015 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>